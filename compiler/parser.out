Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> init start
Rule 2     init -> <empty>
Rule 3     start -> global_variables_declaration functions_definition entry_point_definition
Rule 4     start -> global_variables_declaration entry_point_definition
Rule 5     start -> functions_definition entry_point_definition
Rule 6     start -> entry_point_definition
Rule 7     global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration
Rule 8     parsed_global_scope -> <empty>
Rule 9     functions_definition -> functions_definition single_function_definition
Rule 10    functions_definition -> single_function_definition
Rule 11    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
Rule 12    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
Rule 13    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
Rule 14    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
Rule 15    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
Rule 16    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
Rule 17    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
Rule 18    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block
Rule 19    parsed_function_id -> <empty>
Rule 20    parsed_function_return_type -> <empty>
Rule 21    parsed_function_void_return_type -> <empty>
Rule 22    function_definition_params -> function_definition_params COMMA single_function_definition_param
Rule 23    function_definition_params -> single_function_definition_param
Rule 24    single_function_definition_param -> type ID
Rule 25    entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
Rule 26    entry_point_definition -> START parsed_main_id LPAREN RPAREN instruction_block
Rule 27    parsed_main_id -> <empty>
Rule 28    local_variables_declaration -> LOCAL variables_declaration
Rule 29    variables_declaration -> VARIABLES COLON distinct_type_variables_declaration
Rule 30    distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration
Rule 31    distinct_type_variables_declaration -> shared_type_variables_declaration
Rule 32    shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI
Rule 33    parsed_type -> <empty>
Rule 34    shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration
Rule 35    shared_type_variables_declaration_list -> single_variable_declaration
Rule 36    single_variable_declaration -> ID dim_definition dim_definition
Rule 37    single_variable_declaration -> ID dim_definition
Rule 38    single_variable_declaration -> ID
Rule 39    dim_definition -> LBRACKET CONST_INT RBRACKET
Rule 40    instruction_block -> LBRACE statements RBRACE
Rule 41    instruction_block -> LBRACE RBRACE
Rule 42    statements -> statements single_statement
Rule 43    statements -> single_statement
Rule 44    single_statement -> assignment
Rule 45    single_statement -> function_call
Rule 46    single_statement -> read
Rule 47    single_statement -> print
Rule 48    single_statement -> conditional
Rule 49    single_statement -> loop
Rule 50    single_statement -> return
Rule 51    assignment -> variable_access ASGMT expr SEMI
Rule 52    assignment -> variable_access ASGMT read
Rule 53    variable_access -> ID dim_access dim_access
Rule 54    variable_access -> ID dim_access
Rule 55    variable_access -> ID
Rule 56    dim_access -> LBRACKET expr RBRACKET
Rule 57    function_call -> ID LPAREN function_call_params RPAREN SEMI
Rule 58    function_call -> ID LPAREN RPAREN SEMI
Rule 59    function_call_params -> function_call_params COMMA single_function_call_param
Rule 60    function_call_params -> single_function_call_param
Rule 61    single_function_call_param -> expr
Rule 62    read -> READ LPAREN RPAREN SEMI
Rule 63    print -> PRINT LPAREN print_params RPAREN SEMI
Rule 64    print -> PRINT LPAREN RPAREN SEMI
Rule 65    print_params -> print_params COMMA single_print_param
Rule 66    print_params -> single_print_param
Rule 67    single_print_param -> expr
Rule 68    single_print_param -> CONST_STRING
Rule 69    conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block
Rule 70    conditional -> IF LPAREN expr RPAREN instruction_block
Rule 71    loop -> while
Rule 72    loop -> for
Rule 73    while -> WHILE LPAREN expr RPAREN instruction_block
Rule 74    for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
Rule 75    for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block
Rule 76    return -> RETURN expr SEMI
Rule 77    return -> RETURN SEMI
Rule 78    expr -> expr OR and_expr
Rule 79    expr -> and_expr
Rule 80    and_expr -> equality_expr AND equality_expr
Rule 81    and_expr -> equality_expr
Rule 82    equality_expr -> relational_expr EQUAL relational_expr
Rule 83    equality_expr -> relational_expr NEQUAL relational_expr
Rule 84    equality_expr -> relational_expr
Rule 85    relational_expr -> additive_expr LTHAN_EQUAL additive_expr
Rule 86    relational_expr -> additive_expr LTHAN additive_expr
Rule 87    relational_expr -> additive_expr GTHAN_EQUAL additive_expr
Rule 88    relational_expr -> additive_expr GTHAN additive_expr
Rule 89    relational_expr -> additive_expr
Rule 90    additive_expr -> multiplicative_expr PLUS multiplicative_expr
Rule 91    additive_expr -> multiplicative_expr MINUS multiplicative_expr
Rule 92    additive_expr -> multiplicative_expr
Rule 93    multiplicative_expr -> unary_expr TIMES unary_expr
Rule 94    multiplicative_expr -> unary_expr DIVIDE unary_expr
Rule 95    multiplicative_expr -> unary_expr MODULO unary_expr
Rule 96    multiplicative_expr -> unary_expr
Rule 97    unary_expr -> MINUS postfix_expr
Rule 98    unary_expr -> PLUS postfix_expr
Rule 99    unary_expr -> NOT postfix_expr
Rule 100   unary_expr -> postfix_expr
Rule 101   postfix_expr -> LPAREN expr RPAREN
Rule 102   postfix_expr -> variable_access
Rule 103   postfix_expr -> function_call
Rule 104   postfix_expr -> constant
Rule 105   constant -> CONST_INT
Rule 106   constant -> CONST_REAL
Rule 107   constant -> CONST_CHAR
Rule 108   constant -> constant_bool
Rule 109   constant_bool -> TRUE
Rule 110   constant_bool -> FALSE
Rule 111   type -> INT
Rule 112   type -> REAL
Rule 113   type -> CHAR
Rule 114   type -> BOOL

Terminals, with rules where they appear

AND                  : 80
ASGMT                : 51 52 74 75
BOOL                 : 114
CHAR                 : 113
COLON                : 29 74 74 75
COMMA                : 22 34 59 65
CONST_CHAR           : 107
CONST_INT            : 39 74 74 74 75 75 105
CONST_REAL           : 106
CONST_STRING         : 68
DIVIDE               : 94
ELSE                 : 69
EQUAL                : 82
FALSE                : 110
FROM                 : 74 75
FUNCTION             : 11 12 13 14 15 16 17 18
GLOBAL               : 7
GTHAN                : 88
GTHAN_EQUAL          : 87
ID                   : 11 12 13 14 15 16 17 18 24 36 37 38 53 54 55 57 58 74 75
IF                   : 69 70
INT                  : 111
LBRACE               : 40 41
LBRACKET             : 39 56
LOCAL                : 28
LPAREN               : 11 12 13 14 15 16 17 18 25 26 57 58 62 63 64 69 70 73 74 75 101
LTHAN                : 86
LTHAN_EQUAL          : 85
MINUS                : 91 97
MODULO               : 95
NEQUAL               : 83
NOT                  : 99
OR                   : 78
PLUS                 : 90 98
PRINT                : 63 64
RBRACE               : 40 41
RBRACKET             : 39 56
READ                 : 62
REAL                 : 112
RETURN               : 76 77
RPAREN               : 11 12 13 14 15 16 17 18 25 26 57 58 62 63 64 69 70 73 74 75 101
SEMI                 : 32 51 57 58 62 63 64 76 77
START                : 25 26
TIMES                : 93
TRUE                 : 109
VARIABLES            : 29
VOID                 : 15 16 17 18
WHILE                : 73
error                : 

Nonterminals, with rules where they appear

additive_expr        : 85 85 86 86 87 87 88 88 89
and_expr             : 78 79
assignment           : 44
conditional          : 48
constant             : 104
constant_bool        : 108
dim_access           : 53 53 54
dim_definition       : 36 36 37
distinct_type_variables_declaration : 29 30
entry_point_definition : 3 4 5 6
equality_expr        : 80 80 81
expr                 : 51 56 61 67 69 70 73 76 78 101
for                  : 72
function_call        : 45 103
function_call_params : 57 59
function_definition_params : 11 12 15 16 22
functions_definition : 3 5 9
global_variables_declaration : 3 4
init                 : 1
instruction_block    : 11 12 13 14 15 16 17 18 25 26 69 69 70 73 74 75
local_variables_declaration : 11 13 15 17 25
loop                 : 49
multiplicative_expr  : 90 90 91 91 92
parsed_function_id   : 11 12 13 14 15 16 17 18
parsed_function_return_type : 11 12 13 14
parsed_function_void_return_type : 15 16 17 18
parsed_global_scope  : 7
parsed_main_id       : 25 26
parsed_type          : 32
postfix_expr         : 97 98 99 100
print                : 47
print_params         : 63 65
program              : 0
read                 : 46 52
relational_expr      : 82 82 83 83 84
return               : 50
shared_type_variables_declaration : 30 31
shared_type_variables_declaration_list : 32 34
single_function_call_param : 59 60
single_function_definition : 9 10
single_function_definition_param : 22 23
single_print_param   : 65 66
single_statement     : 42 43
single_variable_declaration : 34 35
start                : 1
statements           : 40 42
type                 : 11 12 13 14 24 32
unary_expr           : 93 93 94 94 95 95 96
variable_access      : 51 52 102
variables_declaration : 7 28
while                : 71

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . init start
    (2) init -> .

    GLOBAL          reduce using rule 2 (init -> .)
    START           reduce using rule 2 (init -> .)
    FUNCTION        reduce using rule 2 (init -> .)

    program                        shift and go to state 1
    init                           shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> init . start
    (3) start -> . global_variables_declaration functions_definition entry_point_definition
    (4) start -> . global_variables_declaration entry_point_definition
    (5) start -> . functions_definition entry_point_definition
    (6) start -> . entry_point_definition
    (7) global_variables_declaration -> . GLOBAL parsed_global_scope variables_declaration
    (9) functions_definition -> . functions_definition single_function_definition
    (10) functions_definition -> . single_function_definition
    (25) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block

    GLOBAL          shift and go to state 7
    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    start                          shift and go to state 3
    global_variables_declaration   shift and go to state 4
    functions_definition           shift and go to state 5
    entry_point_definition         shift and go to state 6
    single_function_definition     shift and go to state 8

state 3

    (1) program -> init start .

    $end            reduce using rule 1 (program -> init start .)


state 4

    (3) start -> global_variables_declaration . functions_definition entry_point_definition
    (4) start -> global_variables_declaration . entry_point_definition
    (9) functions_definition -> . functions_definition single_function_definition
    (10) functions_definition -> . single_function_definition
    (25) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block

    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    functions_definition           shift and go to state 11
    entry_point_definition         shift and go to state 12
    single_function_definition     shift and go to state 8

state 5

    (5) start -> functions_definition . entry_point_definition
    (9) functions_definition -> functions_definition . single_function_definition
    (25) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block

    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    entry_point_definition         shift and go to state 13
    single_function_definition     shift and go to state 14

state 6

    (6) start -> entry_point_definition .

    $end            reduce using rule 6 (start -> entry_point_definition .)


state 7

    (7) global_variables_declaration -> GLOBAL . parsed_global_scope variables_declaration
    (8) parsed_global_scope -> .

    VARIABLES       reduce using rule 8 (parsed_global_scope -> .)

    parsed_global_scope            shift and go to state 15

state 8

    (10) functions_definition -> single_function_definition .

    START           reduce using rule 10 (functions_definition -> single_function_definition .)
    FUNCTION        reduce using rule 10 (functions_definition -> single_function_definition .)


state 9

    (25) entry_point_definition -> START . parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> START . parsed_main_id LPAREN RPAREN instruction_block
    (27) parsed_main_id -> .

    LPAREN          reduce using rule 27 (parsed_main_id -> .)

    parsed_main_id                 shift and go to state 16

state 10

    (11) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (111) type -> . INT
    (112) type -> . REAL
    (113) type -> . CHAR
    (114) type -> . BOOL

    VOID            shift and go to state 18
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    type                           shift and go to state 17

state 11

    (3) start -> global_variables_declaration functions_definition . entry_point_definition
    (9) functions_definition -> functions_definition . single_function_definition
    (25) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block

    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    entry_point_definition         shift and go to state 23
    single_function_definition     shift and go to state 14

state 12

    (4) start -> global_variables_declaration entry_point_definition .

    $end            reduce using rule 4 (start -> global_variables_declaration entry_point_definition .)


state 13

    (5) start -> functions_definition entry_point_definition .

    $end            reduce using rule 5 (start -> functions_definition entry_point_definition .)


state 14

    (9) functions_definition -> functions_definition single_function_definition .

    START           reduce using rule 9 (functions_definition -> functions_definition single_function_definition .)
    FUNCTION        reduce using rule 9 (functions_definition -> functions_definition single_function_definition .)


state 15

    (7) global_variables_declaration -> GLOBAL parsed_global_scope . variables_declaration
    (29) variables_declaration -> . VARIABLES COLON distinct_type_variables_declaration

    VARIABLES       shift and go to state 25

    variables_declaration          shift and go to state 24

state 16

    (25) entry_point_definition -> START parsed_main_id . LPAREN RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> START parsed_main_id . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 26


state 17

    (11) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (20) parsed_function_return_type -> .

    ID              reduce using rule 20 (parsed_function_return_type -> .)

    parsed_function_return_type    shift and go to state 27

state 18

    (15) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block
    (21) parsed_function_void_return_type -> .

    ID              reduce using rule 21 (parsed_function_void_return_type -> .)

    parsed_function_void_return_type shift and go to state 28

state 19

    (111) type -> INT .

    ID              reduce using rule 111 (type -> INT .)


state 20

    (112) type -> REAL .

    ID              reduce using rule 112 (type -> REAL .)


state 21

    (113) type -> CHAR .

    ID              reduce using rule 113 (type -> CHAR .)


state 22

    (114) type -> BOOL .

    ID              reduce using rule 114 (type -> BOOL .)


state 23

    (3) start -> global_variables_declaration functions_definition entry_point_definition .

    $end            reduce using rule 3 (start -> global_variables_declaration functions_definition entry_point_definition .)


state 24

    (7) global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration .

    START           reduce using rule 7 (global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration .)
    FUNCTION        reduce using rule 7 (global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration .)


state 25

    (29) variables_declaration -> VARIABLES . COLON distinct_type_variables_declaration

    COLON           shift and go to state 29


state 26

    (25) entry_point_definition -> START parsed_main_id LPAREN . RPAREN local_variables_declaration instruction_block
    (26) entry_point_definition -> START parsed_main_id LPAREN . RPAREN instruction_block

    RPAREN          shift and go to state 30


state 27

    (11) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_function_id LPAREN RPAREN instruction_block

    ID              shift and go to state 31


state 28

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_function_id LPAREN RPAREN instruction_block

    ID              shift and go to state 32


state 29

    (29) variables_declaration -> VARIABLES COLON . distinct_type_variables_declaration
    (30) distinct_type_variables_declaration -> . distinct_type_variables_declaration shared_type_variables_declaration
    (31) distinct_type_variables_declaration -> . shared_type_variables_declaration
    (32) shared_type_variables_declaration -> . type parsed_type shared_type_variables_declaration_list SEMI
    (111) type -> . INT
    (112) type -> . REAL
    (113) type -> . CHAR
    (114) type -> . BOOL

    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    distinct_type_variables_declaration shift and go to state 33
    shared_type_variables_declaration shift and go to state 34
    type                           shift and go to state 35

state 30

    (25) entry_point_definition -> START parsed_main_id LPAREN RPAREN . local_variables_declaration instruction_block
    (26) entry_point_definition -> START parsed_main_id LPAREN RPAREN . instruction_block
    (28) local_variables_declaration -> . LOCAL variables_declaration
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 36
    instruction_block              shift and go to state 37

state 31

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_function_id LPAREN RPAREN instruction_block
    (19) parsed_function_id -> .

    LPAREN          reduce using rule 19 (parsed_function_id -> .)

    parsed_function_id             shift and go to state 40

state 32

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_function_id LPAREN RPAREN instruction_block
    (19) parsed_function_id -> .

    LPAREN          reduce using rule 19 (parsed_function_id -> .)

    parsed_function_id             shift and go to state 41

state 33

    (29) variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .
    (30) distinct_type_variables_declaration -> distinct_type_variables_declaration . shared_type_variables_declaration
    (32) shared_type_variables_declaration -> . type parsed_type shared_type_variables_declaration_list SEMI
    (111) type -> . INT
    (112) type -> . REAL
    (113) type -> . CHAR
    (114) type -> . BOOL

    START           reduce using rule 29 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    FUNCTION        reduce using rule 29 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    LBRACE          reduce using rule 29 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    shared_type_variables_declaration shift and go to state 42
    type                           shift and go to state 35

state 34

    (31) distinct_type_variables_declaration -> shared_type_variables_declaration .

    INT             reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    REAL            reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    CHAR            reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    BOOL            reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    START           reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    FUNCTION        reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    LBRACE          reduce using rule 31 (distinct_type_variables_declaration -> shared_type_variables_declaration .)


state 35

    (32) shared_type_variables_declaration -> type . parsed_type shared_type_variables_declaration_list SEMI
    (33) parsed_type -> .

    ID              reduce using rule 33 (parsed_type -> .)

    parsed_type                    shift and go to state 43

state 36

    (25) entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 44

state 37

    (26) entry_point_definition -> START parsed_main_id LPAREN RPAREN instruction_block .

    $end            reduce using rule 26 (entry_point_definition -> START parsed_main_id LPAREN RPAREN instruction_block .)


state 38

    (28) local_variables_declaration -> LOCAL . variables_declaration
    (29) variables_declaration -> . VARIABLES COLON distinct_type_variables_declaration

    VARIABLES       shift and go to state 25

    variables_declaration          shift and go to state 45

state 39

    (40) instruction_block -> LBRACE . statements RBRACE
    (41) instruction_block -> LBRACE . RBRACE
    (42) statements -> . statements single_statement
    (43) statements -> . single_statement
    (44) single_statement -> . assignment
    (45) single_statement -> . function_call
    (46) single_statement -> . read
    (47) single_statement -> . print
    (48) single_statement -> . conditional
    (49) single_statement -> . loop
    (50) single_statement -> . return
    (51) assignment -> . variable_access ASGMT expr SEMI
    (52) assignment -> . variable_access ASGMT read
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (62) read -> . READ LPAREN RPAREN SEMI
    (63) print -> . PRINT LPAREN print_params RPAREN SEMI
    (64) print -> . PRINT LPAREN RPAREN SEMI
    (69) conditional -> . IF LPAREN expr RPAREN instruction_block ELSE instruction_block
    (70) conditional -> . IF LPAREN expr RPAREN instruction_block
    (71) loop -> . while
    (72) loop -> . for
    (76) return -> . RETURN expr SEMI
    (77) return -> . RETURN SEMI
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (73) while -> . WHILE LPAREN expr RPAREN instruction_block
    (74) for -> . FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> . FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    RBRACE          shift and go to state 47
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    RETURN          shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    statements                     shift and go to state 46
    single_statement               shift and go to state 48
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    return                         shift and go to state 55
    variable_access                shift and go to state 56
    while                          shift and go to state 61
    for                            shift and go to state 62

state 40

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id . LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id . LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id . LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 66


state 41

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id . LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id . LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id . LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 67


state 42

    (30) distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .

    INT             reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    REAL            reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    CHAR            reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    BOOL            reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    START           reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    FUNCTION        reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    LBRACE          reduce using rule 30 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)


state 43

    (32) shared_type_variables_declaration -> type parsed_type . shared_type_variables_declaration_list SEMI
    (34) shared_type_variables_declaration_list -> . shared_type_variables_declaration_list COMMA single_variable_declaration
    (35) shared_type_variables_declaration_list -> . single_variable_declaration
    (36) single_variable_declaration -> . ID dim_definition dim_definition
    (37) single_variable_declaration -> . ID dim_definition
    (38) single_variable_declaration -> . ID

    ID              shift and go to state 70

    shared_type_variables_declaration_list shift and go to state 68
    single_variable_declaration    shift and go to state 69

state 44

    (25) entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block .

    $end            reduce using rule 25 (entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block .)


state 45

    (28) local_variables_declaration -> LOCAL variables_declaration .

    LBRACE          reduce using rule 28 (local_variables_declaration -> LOCAL variables_declaration .)


state 46

    (40) instruction_block -> LBRACE statements . RBRACE
    (42) statements -> statements . single_statement
    (44) single_statement -> . assignment
    (45) single_statement -> . function_call
    (46) single_statement -> . read
    (47) single_statement -> . print
    (48) single_statement -> . conditional
    (49) single_statement -> . loop
    (50) single_statement -> . return
    (51) assignment -> . variable_access ASGMT expr SEMI
    (52) assignment -> . variable_access ASGMT read
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (62) read -> . READ LPAREN RPAREN SEMI
    (63) print -> . PRINT LPAREN print_params RPAREN SEMI
    (64) print -> . PRINT LPAREN RPAREN SEMI
    (69) conditional -> . IF LPAREN expr RPAREN instruction_block ELSE instruction_block
    (70) conditional -> . IF LPAREN expr RPAREN instruction_block
    (71) loop -> . while
    (72) loop -> . for
    (76) return -> . RETURN expr SEMI
    (77) return -> . RETURN SEMI
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (73) while -> . WHILE LPAREN expr RPAREN instruction_block
    (74) for -> . FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> . FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    RBRACE          shift and go to state 71
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    RETURN          shift and go to state 63
    WHILE           shift and go to state 64
    FROM            shift and go to state 65

    single_statement               shift and go to state 72
    assignment                     shift and go to state 49
    function_call                  shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    return                         shift and go to state 55
    variable_access                shift and go to state 56
    while                          shift and go to state 61
    for                            shift and go to state 62

state 47

    (41) instruction_block -> LBRACE RBRACE .

    $end            reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    START           reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    ELSE            reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    ID              reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    READ            reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    PRINT           reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    IF              reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    RETURN          reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    WHILE           reduce using rule 41 (instruction_block -> LBRACE RBRACE .)
    FROM            reduce using rule 41 (instruction_block -> LBRACE RBRACE .)


state 48

    (43) statements -> single_statement .

    RBRACE          reduce using rule 43 (statements -> single_statement .)
    ID              reduce using rule 43 (statements -> single_statement .)
    READ            reduce using rule 43 (statements -> single_statement .)
    PRINT           reduce using rule 43 (statements -> single_statement .)
    IF              reduce using rule 43 (statements -> single_statement .)
    RETURN          reduce using rule 43 (statements -> single_statement .)
    WHILE           reduce using rule 43 (statements -> single_statement .)
    FROM            reduce using rule 43 (statements -> single_statement .)


state 49

    (44) single_statement -> assignment .

    RBRACE          reduce using rule 44 (single_statement -> assignment .)
    ID              reduce using rule 44 (single_statement -> assignment .)
    READ            reduce using rule 44 (single_statement -> assignment .)
    PRINT           reduce using rule 44 (single_statement -> assignment .)
    IF              reduce using rule 44 (single_statement -> assignment .)
    RETURN          reduce using rule 44 (single_statement -> assignment .)
    WHILE           reduce using rule 44 (single_statement -> assignment .)
    FROM            reduce using rule 44 (single_statement -> assignment .)


state 50

    (45) single_statement -> function_call .

    RBRACE          reduce using rule 45 (single_statement -> function_call .)
    ID              reduce using rule 45 (single_statement -> function_call .)
    READ            reduce using rule 45 (single_statement -> function_call .)
    PRINT           reduce using rule 45 (single_statement -> function_call .)
    IF              reduce using rule 45 (single_statement -> function_call .)
    RETURN          reduce using rule 45 (single_statement -> function_call .)
    WHILE           reduce using rule 45 (single_statement -> function_call .)
    FROM            reduce using rule 45 (single_statement -> function_call .)


state 51

    (46) single_statement -> read .

    RBRACE          reduce using rule 46 (single_statement -> read .)
    ID              reduce using rule 46 (single_statement -> read .)
    READ            reduce using rule 46 (single_statement -> read .)
    PRINT           reduce using rule 46 (single_statement -> read .)
    IF              reduce using rule 46 (single_statement -> read .)
    RETURN          reduce using rule 46 (single_statement -> read .)
    WHILE           reduce using rule 46 (single_statement -> read .)
    FROM            reduce using rule 46 (single_statement -> read .)


state 52

    (47) single_statement -> print .

    RBRACE          reduce using rule 47 (single_statement -> print .)
    ID              reduce using rule 47 (single_statement -> print .)
    READ            reduce using rule 47 (single_statement -> print .)
    PRINT           reduce using rule 47 (single_statement -> print .)
    IF              reduce using rule 47 (single_statement -> print .)
    RETURN          reduce using rule 47 (single_statement -> print .)
    WHILE           reduce using rule 47 (single_statement -> print .)
    FROM            reduce using rule 47 (single_statement -> print .)


state 53

    (48) single_statement -> conditional .

    RBRACE          reduce using rule 48 (single_statement -> conditional .)
    ID              reduce using rule 48 (single_statement -> conditional .)
    READ            reduce using rule 48 (single_statement -> conditional .)
    PRINT           reduce using rule 48 (single_statement -> conditional .)
    IF              reduce using rule 48 (single_statement -> conditional .)
    RETURN          reduce using rule 48 (single_statement -> conditional .)
    WHILE           reduce using rule 48 (single_statement -> conditional .)
    FROM            reduce using rule 48 (single_statement -> conditional .)


state 54

    (49) single_statement -> loop .

    RBRACE          reduce using rule 49 (single_statement -> loop .)
    ID              reduce using rule 49 (single_statement -> loop .)
    READ            reduce using rule 49 (single_statement -> loop .)
    PRINT           reduce using rule 49 (single_statement -> loop .)
    IF              reduce using rule 49 (single_statement -> loop .)
    RETURN          reduce using rule 49 (single_statement -> loop .)
    WHILE           reduce using rule 49 (single_statement -> loop .)
    FROM            reduce using rule 49 (single_statement -> loop .)


state 55

    (50) single_statement -> return .

    RBRACE          reduce using rule 50 (single_statement -> return .)
    ID              reduce using rule 50 (single_statement -> return .)
    READ            reduce using rule 50 (single_statement -> return .)
    PRINT           reduce using rule 50 (single_statement -> return .)
    IF              reduce using rule 50 (single_statement -> return .)
    RETURN          reduce using rule 50 (single_statement -> return .)
    WHILE           reduce using rule 50 (single_statement -> return .)
    FROM            reduce using rule 50 (single_statement -> return .)


state 56

    (51) assignment -> variable_access . ASGMT expr SEMI
    (52) assignment -> variable_access . ASGMT read

    ASGMT           shift and go to state 73


state 57

    (57) function_call -> ID . LPAREN function_call_params RPAREN SEMI
    (58) function_call -> ID . LPAREN RPAREN SEMI
    (53) variable_access -> ID . dim_access dim_access
    (54) variable_access -> ID . dim_access
    (55) variable_access -> ID .
    (56) dim_access -> . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 74
    ASGMT           reduce using rule 55 (variable_access -> ID .)
    LBRACKET        shift and go to state 76

    dim_access                     shift and go to state 75

state 58

    (62) read -> READ . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 77


state 59

    (63) print -> PRINT . LPAREN print_params RPAREN SEMI
    (64) print -> PRINT . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 78


state 60

    (69) conditional -> IF . LPAREN expr RPAREN instruction_block ELSE instruction_block
    (70) conditional -> IF . LPAREN expr RPAREN instruction_block

    LPAREN          shift and go to state 79


state 61

    (71) loop -> while .

    RBRACE          reduce using rule 71 (loop -> while .)
    ID              reduce using rule 71 (loop -> while .)
    READ            reduce using rule 71 (loop -> while .)
    PRINT           reduce using rule 71 (loop -> while .)
    IF              reduce using rule 71 (loop -> while .)
    RETURN          reduce using rule 71 (loop -> while .)
    WHILE           reduce using rule 71 (loop -> while .)
    FROM            reduce using rule 71 (loop -> while .)


state 62

    (72) loop -> for .

    RBRACE          reduce using rule 72 (loop -> for .)
    ID              reduce using rule 72 (loop -> for .)
    READ            reduce using rule 72 (loop -> for .)
    PRINT           reduce using rule 72 (loop -> for .)
    IF              reduce using rule 72 (loop -> for .)
    RETURN          reduce using rule 72 (loop -> for .)
    WHILE           reduce using rule 72 (loop -> for .)
    FROM            reduce using rule 72 (loop -> for .)


state 63

    (76) return -> RETURN . expr SEMI
    (77) return -> RETURN . SEMI
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    SEMI            shift and go to state 81
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 80
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 64

    (73) while -> WHILE . LPAREN expr RPAREN instruction_block

    LPAREN          shift and go to state 103


state 65

    (74) for -> FROM . LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM . LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    LPAREN          shift and go to state 104


state 66

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN . function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN . function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN . RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN . RPAREN instruction_block
    (22) function_definition_params -> . function_definition_params COMMA single_function_definition_param
    (23) function_definition_params -> . single_function_definition_param
    (24) single_function_definition_param -> . type ID
    (111) type -> . INT
    (112) type -> . REAL
    (113) type -> . CHAR
    (114) type -> . BOOL

    RPAREN          shift and go to state 107
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    type                           shift and go to state 105
    function_definition_params     shift and go to state 106
    single_function_definition_param shift and go to state 108

state 67

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN . function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN . function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN . RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN . RPAREN instruction_block
    (22) function_definition_params -> . function_definition_params COMMA single_function_definition_param
    (23) function_definition_params -> . single_function_definition_param
    (24) single_function_definition_param -> . type ID
    (111) type -> . INT
    (112) type -> . REAL
    (113) type -> . CHAR
    (114) type -> . BOOL

    RPAREN          shift and go to state 110
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    function_definition_params     shift and go to state 109
    single_function_definition_param shift and go to state 108
    type                           shift and go to state 105

state 68

    (32) shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list . SEMI
    (34) shared_type_variables_declaration_list -> shared_type_variables_declaration_list . COMMA single_variable_declaration

    SEMI            shift and go to state 111
    COMMA           shift and go to state 112


state 69

    (35) shared_type_variables_declaration_list -> single_variable_declaration .

    SEMI            reduce using rule 35 (shared_type_variables_declaration_list -> single_variable_declaration .)
    COMMA           reduce using rule 35 (shared_type_variables_declaration_list -> single_variable_declaration .)


state 70

    (36) single_variable_declaration -> ID . dim_definition dim_definition
    (37) single_variable_declaration -> ID . dim_definition
    (38) single_variable_declaration -> ID .
    (39) dim_definition -> . LBRACKET CONST_INT RBRACKET

    SEMI            reduce using rule 38 (single_variable_declaration -> ID .)
    COMMA           reduce using rule 38 (single_variable_declaration -> ID .)
    LBRACKET        shift and go to state 114

    dim_definition                 shift and go to state 113

state 71

    (40) instruction_block -> LBRACE statements RBRACE .

    $end            reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    START           reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    FUNCTION        reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    ID              reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    READ            reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    PRINT           reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    IF              reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)
    FROM            reduce using rule 40 (instruction_block -> LBRACE statements RBRACE .)


state 72

    (42) statements -> statements single_statement .

    RBRACE          reduce using rule 42 (statements -> statements single_statement .)
    ID              reduce using rule 42 (statements -> statements single_statement .)
    READ            reduce using rule 42 (statements -> statements single_statement .)
    PRINT           reduce using rule 42 (statements -> statements single_statement .)
    IF              reduce using rule 42 (statements -> statements single_statement .)
    RETURN          reduce using rule 42 (statements -> statements single_statement .)
    WHILE           reduce using rule 42 (statements -> statements single_statement .)
    FROM            reduce using rule 42 (statements -> statements single_statement .)


state 73

    (51) assignment -> variable_access ASGMT . expr SEMI
    (52) assignment -> variable_access ASGMT . read
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (62) read -> . READ LPAREN RPAREN SEMI
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    READ            shift and go to state 58
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    variable_access                shift and go to state 93
    expr                           shift and go to state 115
    read                           shift and go to state 116
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 74

    (57) function_call -> ID LPAREN . function_call_params RPAREN SEMI
    (58) function_call -> ID LPAREN . RPAREN SEMI
    (59) function_call_params -> . function_call_params COMMA single_function_call_param
    (60) function_call_params -> . single_function_call_param
    (61) single_function_call_param -> . expr
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    RPAREN          shift and go to state 118
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    function_call_params           shift and go to state 117
    single_function_call_param     shift and go to state 119
    expr                           shift and go to state 120
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 75

    (53) variable_access -> ID dim_access . dim_access
    (54) variable_access -> ID dim_access .
    (56) dim_access -> . LBRACKET expr RBRACKET

    ASGMT           reduce using rule 54 (variable_access -> ID dim_access .)
    TIMES           reduce using rule 54 (variable_access -> ID dim_access .)
    DIVIDE          reduce using rule 54 (variable_access -> ID dim_access .)
    MODULO          reduce using rule 54 (variable_access -> ID dim_access .)
    PLUS            reduce using rule 54 (variable_access -> ID dim_access .)
    MINUS           reduce using rule 54 (variable_access -> ID dim_access .)
    LTHAN_EQUAL     reduce using rule 54 (variable_access -> ID dim_access .)
    LTHAN           reduce using rule 54 (variable_access -> ID dim_access .)
    GTHAN_EQUAL     reduce using rule 54 (variable_access -> ID dim_access .)
    GTHAN           reduce using rule 54 (variable_access -> ID dim_access .)
    EQUAL           reduce using rule 54 (variable_access -> ID dim_access .)
    NEQUAL          reduce using rule 54 (variable_access -> ID dim_access .)
    AND             reduce using rule 54 (variable_access -> ID dim_access .)
    SEMI            reduce using rule 54 (variable_access -> ID dim_access .)
    OR              reduce using rule 54 (variable_access -> ID dim_access .)
    RPAREN          reduce using rule 54 (variable_access -> ID dim_access .)
    COMMA           reduce using rule 54 (variable_access -> ID dim_access .)
    RBRACKET        reduce using rule 54 (variable_access -> ID dim_access .)
    LBRACKET        shift and go to state 76

    dim_access                     shift and go to state 121

state 76

    (56) dim_access -> LBRACKET . expr RBRACKET
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 122
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 77

    (62) read -> READ LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 123


state 78

    (63) print -> PRINT LPAREN . print_params RPAREN SEMI
    (64) print -> PRINT LPAREN . RPAREN SEMI
    (65) print_params -> . print_params COMMA single_print_param
    (66) print_params -> . single_print_param
    (67) single_print_param -> . expr
    (68) single_print_param -> . CONST_STRING
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    RPAREN          shift and go to state 125
    CONST_STRING    shift and go to state 128
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    print_params                   shift and go to state 124
    single_print_param             shift and go to state 126
    expr                           shift and go to state 127
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 79

    (69) conditional -> IF LPAREN . expr RPAREN instruction_block ELSE instruction_block
    (70) conditional -> IF LPAREN . expr RPAREN instruction_block
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 129
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 80

    (76) return -> RETURN expr . SEMI
    (78) expr -> expr . OR and_expr

    SEMI            shift and go to state 130
    OR              shift and go to state 131


state 81

    (77) return -> RETURN SEMI .

    RBRACE          reduce using rule 77 (return -> RETURN SEMI .)
    ID              reduce using rule 77 (return -> RETURN SEMI .)
    READ            reduce using rule 77 (return -> RETURN SEMI .)
    PRINT           reduce using rule 77 (return -> RETURN SEMI .)
    IF              reduce using rule 77 (return -> RETURN SEMI .)
    RETURN          reduce using rule 77 (return -> RETURN SEMI .)
    WHILE           reduce using rule 77 (return -> RETURN SEMI .)
    FROM            reduce using rule 77 (return -> RETURN SEMI .)


state 82

    (79) expr -> and_expr .

    SEMI            reduce using rule 79 (expr -> and_expr .)
    OR              reduce using rule 79 (expr -> and_expr .)
    RPAREN          reduce using rule 79 (expr -> and_expr .)
    COMMA           reduce using rule 79 (expr -> and_expr .)
    RBRACKET        reduce using rule 79 (expr -> and_expr .)


state 83

    (80) and_expr -> equality_expr . AND equality_expr
    (81) and_expr -> equality_expr .

    AND             shift and go to state 132
    SEMI            reduce using rule 81 (and_expr -> equality_expr .)
    OR              reduce using rule 81 (and_expr -> equality_expr .)
    RPAREN          reduce using rule 81 (and_expr -> equality_expr .)
    COMMA           reduce using rule 81 (and_expr -> equality_expr .)
    RBRACKET        reduce using rule 81 (and_expr -> equality_expr .)


state 84

    (82) equality_expr -> relational_expr . EQUAL relational_expr
    (83) equality_expr -> relational_expr . NEQUAL relational_expr
    (84) equality_expr -> relational_expr .

    EQUAL           shift and go to state 133
    NEQUAL          shift and go to state 134
    AND             reduce using rule 84 (equality_expr -> relational_expr .)
    SEMI            reduce using rule 84 (equality_expr -> relational_expr .)
    OR              reduce using rule 84 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 84 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 84 (equality_expr -> relational_expr .)
    RBRACKET        reduce using rule 84 (equality_expr -> relational_expr .)


state 85

    (85) relational_expr -> additive_expr . LTHAN_EQUAL additive_expr
    (86) relational_expr -> additive_expr . LTHAN additive_expr
    (87) relational_expr -> additive_expr . GTHAN_EQUAL additive_expr
    (88) relational_expr -> additive_expr . GTHAN additive_expr
    (89) relational_expr -> additive_expr .

    LTHAN_EQUAL     shift and go to state 135
    LTHAN           shift and go to state 136
    GTHAN_EQUAL     shift and go to state 137
    GTHAN           shift and go to state 138
    EQUAL           reduce using rule 89 (relational_expr -> additive_expr .)
    NEQUAL          reduce using rule 89 (relational_expr -> additive_expr .)
    AND             reduce using rule 89 (relational_expr -> additive_expr .)
    SEMI            reduce using rule 89 (relational_expr -> additive_expr .)
    OR              reduce using rule 89 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 89 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 89 (relational_expr -> additive_expr .)
    RBRACKET        reduce using rule 89 (relational_expr -> additive_expr .)


state 86

    (90) additive_expr -> multiplicative_expr . PLUS multiplicative_expr
    (91) additive_expr -> multiplicative_expr . MINUS multiplicative_expr
    (92) additive_expr -> multiplicative_expr .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    LTHAN_EQUAL     reduce using rule 92 (additive_expr -> multiplicative_expr .)
    LTHAN           reduce using rule 92 (additive_expr -> multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 92 (additive_expr -> multiplicative_expr .)
    GTHAN           reduce using rule 92 (additive_expr -> multiplicative_expr .)
    EQUAL           reduce using rule 92 (additive_expr -> multiplicative_expr .)
    NEQUAL          reduce using rule 92 (additive_expr -> multiplicative_expr .)
    AND             reduce using rule 92 (additive_expr -> multiplicative_expr .)
    SEMI            reduce using rule 92 (additive_expr -> multiplicative_expr .)
    OR              reduce using rule 92 (additive_expr -> multiplicative_expr .)
    RPAREN          reduce using rule 92 (additive_expr -> multiplicative_expr .)
    COMMA           reduce using rule 92 (additive_expr -> multiplicative_expr .)
    RBRACKET        reduce using rule 92 (additive_expr -> multiplicative_expr .)


state 87

    (98) unary_expr -> PLUS . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    postfix_expr                   shift and go to state 141
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 88

    (97) unary_expr -> MINUS . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    postfix_expr                   shift and go to state 142
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 89

    (93) multiplicative_expr -> unary_expr . TIMES unary_expr
    (94) multiplicative_expr -> unary_expr . DIVIDE unary_expr
    (95) multiplicative_expr -> unary_expr . MODULO unary_expr
    (96) multiplicative_expr -> unary_expr .

    TIMES           shift and go to state 143
    DIVIDE          shift and go to state 144
    MODULO          shift and go to state 145
    PLUS            reduce using rule 96 (multiplicative_expr -> unary_expr .)
    MINUS           reduce using rule 96 (multiplicative_expr -> unary_expr .)
    LTHAN_EQUAL     reduce using rule 96 (multiplicative_expr -> unary_expr .)
    LTHAN           reduce using rule 96 (multiplicative_expr -> unary_expr .)
    GTHAN_EQUAL     reduce using rule 96 (multiplicative_expr -> unary_expr .)
    GTHAN           reduce using rule 96 (multiplicative_expr -> unary_expr .)
    EQUAL           reduce using rule 96 (multiplicative_expr -> unary_expr .)
    NEQUAL          reduce using rule 96 (multiplicative_expr -> unary_expr .)
    AND             reduce using rule 96 (multiplicative_expr -> unary_expr .)
    SEMI            reduce using rule 96 (multiplicative_expr -> unary_expr .)
    OR              reduce using rule 96 (multiplicative_expr -> unary_expr .)
    RPAREN          reduce using rule 96 (multiplicative_expr -> unary_expr .)
    COMMA           reduce using rule 96 (multiplicative_expr -> unary_expr .)
    RBRACKET        reduce using rule 96 (multiplicative_expr -> unary_expr .)


state 90

    (100) unary_expr -> postfix_expr .

    TIMES           reduce using rule 100 (unary_expr -> postfix_expr .)
    DIVIDE          reduce using rule 100 (unary_expr -> postfix_expr .)
    MODULO          reduce using rule 100 (unary_expr -> postfix_expr .)
    PLUS            reduce using rule 100 (unary_expr -> postfix_expr .)
    MINUS           reduce using rule 100 (unary_expr -> postfix_expr .)
    LTHAN_EQUAL     reduce using rule 100 (unary_expr -> postfix_expr .)
    LTHAN           reduce using rule 100 (unary_expr -> postfix_expr .)
    GTHAN_EQUAL     reduce using rule 100 (unary_expr -> postfix_expr .)
    GTHAN           reduce using rule 100 (unary_expr -> postfix_expr .)
    EQUAL           reduce using rule 100 (unary_expr -> postfix_expr .)
    NEQUAL          reduce using rule 100 (unary_expr -> postfix_expr .)
    AND             reduce using rule 100 (unary_expr -> postfix_expr .)
    SEMI            reduce using rule 100 (unary_expr -> postfix_expr .)
    OR              reduce using rule 100 (unary_expr -> postfix_expr .)
    RPAREN          reduce using rule 100 (unary_expr -> postfix_expr .)
    COMMA           reduce using rule 100 (unary_expr -> postfix_expr .)
    RBRACKET        reduce using rule 100 (unary_expr -> postfix_expr .)


state 91

    (99) unary_expr -> NOT . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    postfix_expr                   shift and go to state 146
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 92

    (101) postfix_expr -> LPAREN . expr RPAREN
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 147
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 93

    (102) postfix_expr -> variable_access .

    TIMES           reduce using rule 102 (postfix_expr -> variable_access .)
    DIVIDE          reduce using rule 102 (postfix_expr -> variable_access .)
    MODULO          reduce using rule 102 (postfix_expr -> variable_access .)
    PLUS            reduce using rule 102 (postfix_expr -> variable_access .)
    MINUS           reduce using rule 102 (postfix_expr -> variable_access .)
    LTHAN_EQUAL     reduce using rule 102 (postfix_expr -> variable_access .)
    LTHAN           reduce using rule 102 (postfix_expr -> variable_access .)
    GTHAN_EQUAL     reduce using rule 102 (postfix_expr -> variable_access .)
    GTHAN           reduce using rule 102 (postfix_expr -> variable_access .)
    EQUAL           reduce using rule 102 (postfix_expr -> variable_access .)
    NEQUAL          reduce using rule 102 (postfix_expr -> variable_access .)
    AND             reduce using rule 102 (postfix_expr -> variable_access .)
    SEMI            reduce using rule 102 (postfix_expr -> variable_access .)
    OR              reduce using rule 102 (postfix_expr -> variable_access .)
    RPAREN          reduce using rule 102 (postfix_expr -> variable_access .)
    COMMA           reduce using rule 102 (postfix_expr -> variable_access .)
    RBRACKET        reduce using rule 102 (postfix_expr -> variable_access .)


state 94

    (103) postfix_expr -> function_call .

    TIMES           reduce using rule 103 (postfix_expr -> function_call .)
    DIVIDE          reduce using rule 103 (postfix_expr -> function_call .)
    MODULO          reduce using rule 103 (postfix_expr -> function_call .)
    PLUS            reduce using rule 103 (postfix_expr -> function_call .)
    MINUS           reduce using rule 103 (postfix_expr -> function_call .)
    LTHAN_EQUAL     reduce using rule 103 (postfix_expr -> function_call .)
    LTHAN           reduce using rule 103 (postfix_expr -> function_call .)
    GTHAN_EQUAL     reduce using rule 103 (postfix_expr -> function_call .)
    GTHAN           reduce using rule 103 (postfix_expr -> function_call .)
    EQUAL           reduce using rule 103 (postfix_expr -> function_call .)
    NEQUAL          reduce using rule 103 (postfix_expr -> function_call .)
    AND             reduce using rule 103 (postfix_expr -> function_call .)
    SEMI            reduce using rule 103 (postfix_expr -> function_call .)
    OR              reduce using rule 103 (postfix_expr -> function_call .)
    RPAREN          reduce using rule 103 (postfix_expr -> function_call .)
    COMMA           reduce using rule 103 (postfix_expr -> function_call .)
    RBRACKET        reduce using rule 103 (postfix_expr -> function_call .)


state 95

    (104) postfix_expr -> constant .

    TIMES           reduce using rule 104 (postfix_expr -> constant .)
    DIVIDE          reduce using rule 104 (postfix_expr -> constant .)
    MODULO          reduce using rule 104 (postfix_expr -> constant .)
    PLUS            reduce using rule 104 (postfix_expr -> constant .)
    MINUS           reduce using rule 104 (postfix_expr -> constant .)
    LTHAN_EQUAL     reduce using rule 104 (postfix_expr -> constant .)
    LTHAN           reduce using rule 104 (postfix_expr -> constant .)
    GTHAN_EQUAL     reduce using rule 104 (postfix_expr -> constant .)
    GTHAN           reduce using rule 104 (postfix_expr -> constant .)
    EQUAL           reduce using rule 104 (postfix_expr -> constant .)
    NEQUAL          reduce using rule 104 (postfix_expr -> constant .)
    AND             reduce using rule 104 (postfix_expr -> constant .)
    SEMI            reduce using rule 104 (postfix_expr -> constant .)
    OR              reduce using rule 104 (postfix_expr -> constant .)
    RPAREN          reduce using rule 104 (postfix_expr -> constant .)
    COMMA           reduce using rule 104 (postfix_expr -> constant .)
    RBRACKET        reduce using rule 104 (postfix_expr -> constant .)


state 96

    (53) variable_access -> ID . dim_access dim_access
    (54) variable_access -> ID . dim_access
    (55) variable_access -> ID .
    (57) function_call -> ID . LPAREN function_call_params RPAREN SEMI
    (58) function_call -> ID . LPAREN RPAREN SEMI
    (56) dim_access -> . LBRACKET expr RBRACKET

    TIMES           reduce using rule 55 (variable_access -> ID .)
    DIVIDE          reduce using rule 55 (variable_access -> ID .)
    MODULO          reduce using rule 55 (variable_access -> ID .)
    PLUS            reduce using rule 55 (variable_access -> ID .)
    MINUS           reduce using rule 55 (variable_access -> ID .)
    LTHAN_EQUAL     reduce using rule 55 (variable_access -> ID .)
    LTHAN           reduce using rule 55 (variable_access -> ID .)
    GTHAN_EQUAL     reduce using rule 55 (variable_access -> ID .)
    GTHAN           reduce using rule 55 (variable_access -> ID .)
    EQUAL           reduce using rule 55 (variable_access -> ID .)
    NEQUAL          reduce using rule 55 (variable_access -> ID .)
    AND             reduce using rule 55 (variable_access -> ID .)
    SEMI            reduce using rule 55 (variable_access -> ID .)
    OR              reduce using rule 55 (variable_access -> ID .)
    RPAREN          reduce using rule 55 (variable_access -> ID .)
    COMMA           reduce using rule 55 (variable_access -> ID .)
    RBRACKET        reduce using rule 55 (variable_access -> ID .)
    LPAREN          shift and go to state 74
    LBRACKET        shift and go to state 76

    dim_access                     shift and go to state 75

state 97

    (105) constant -> CONST_INT .

    TIMES           reduce using rule 105 (constant -> CONST_INT .)
    DIVIDE          reduce using rule 105 (constant -> CONST_INT .)
    MODULO          reduce using rule 105 (constant -> CONST_INT .)
    PLUS            reduce using rule 105 (constant -> CONST_INT .)
    MINUS           reduce using rule 105 (constant -> CONST_INT .)
    LTHAN_EQUAL     reduce using rule 105 (constant -> CONST_INT .)
    LTHAN           reduce using rule 105 (constant -> CONST_INT .)
    GTHAN_EQUAL     reduce using rule 105 (constant -> CONST_INT .)
    GTHAN           reduce using rule 105 (constant -> CONST_INT .)
    EQUAL           reduce using rule 105 (constant -> CONST_INT .)
    NEQUAL          reduce using rule 105 (constant -> CONST_INT .)
    AND             reduce using rule 105 (constant -> CONST_INT .)
    SEMI            reduce using rule 105 (constant -> CONST_INT .)
    OR              reduce using rule 105 (constant -> CONST_INT .)
    RPAREN          reduce using rule 105 (constant -> CONST_INT .)
    COMMA           reduce using rule 105 (constant -> CONST_INT .)
    RBRACKET        reduce using rule 105 (constant -> CONST_INT .)


state 98

    (106) constant -> CONST_REAL .

    TIMES           reduce using rule 106 (constant -> CONST_REAL .)
    DIVIDE          reduce using rule 106 (constant -> CONST_REAL .)
    MODULO          reduce using rule 106 (constant -> CONST_REAL .)
    PLUS            reduce using rule 106 (constant -> CONST_REAL .)
    MINUS           reduce using rule 106 (constant -> CONST_REAL .)
    LTHAN_EQUAL     reduce using rule 106 (constant -> CONST_REAL .)
    LTHAN           reduce using rule 106 (constant -> CONST_REAL .)
    GTHAN_EQUAL     reduce using rule 106 (constant -> CONST_REAL .)
    GTHAN           reduce using rule 106 (constant -> CONST_REAL .)
    EQUAL           reduce using rule 106 (constant -> CONST_REAL .)
    NEQUAL          reduce using rule 106 (constant -> CONST_REAL .)
    AND             reduce using rule 106 (constant -> CONST_REAL .)
    SEMI            reduce using rule 106 (constant -> CONST_REAL .)
    OR              reduce using rule 106 (constant -> CONST_REAL .)
    RPAREN          reduce using rule 106 (constant -> CONST_REAL .)
    COMMA           reduce using rule 106 (constant -> CONST_REAL .)
    RBRACKET        reduce using rule 106 (constant -> CONST_REAL .)


state 99

    (107) constant -> CONST_CHAR .

    TIMES           reduce using rule 107 (constant -> CONST_CHAR .)
    DIVIDE          reduce using rule 107 (constant -> CONST_CHAR .)
    MODULO          reduce using rule 107 (constant -> CONST_CHAR .)
    PLUS            reduce using rule 107 (constant -> CONST_CHAR .)
    MINUS           reduce using rule 107 (constant -> CONST_CHAR .)
    LTHAN_EQUAL     reduce using rule 107 (constant -> CONST_CHAR .)
    LTHAN           reduce using rule 107 (constant -> CONST_CHAR .)
    GTHAN_EQUAL     reduce using rule 107 (constant -> CONST_CHAR .)
    GTHAN           reduce using rule 107 (constant -> CONST_CHAR .)
    EQUAL           reduce using rule 107 (constant -> CONST_CHAR .)
    NEQUAL          reduce using rule 107 (constant -> CONST_CHAR .)
    AND             reduce using rule 107 (constant -> CONST_CHAR .)
    SEMI            reduce using rule 107 (constant -> CONST_CHAR .)
    OR              reduce using rule 107 (constant -> CONST_CHAR .)
    RPAREN          reduce using rule 107 (constant -> CONST_CHAR .)
    COMMA           reduce using rule 107 (constant -> CONST_CHAR .)
    RBRACKET        reduce using rule 107 (constant -> CONST_CHAR .)


state 100

    (108) constant -> constant_bool .

    TIMES           reduce using rule 108 (constant -> constant_bool .)
    DIVIDE          reduce using rule 108 (constant -> constant_bool .)
    MODULO          reduce using rule 108 (constant -> constant_bool .)
    PLUS            reduce using rule 108 (constant -> constant_bool .)
    MINUS           reduce using rule 108 (constant -> constant_bool .)
    LTHAN_EQUAL     reduce using rule 108 (constant -> constant_bool .)
    LTHAN           reduce using rule 108 (constant -> constant_bool .)
    GTHAN_EQUAL     reduce using rule 108 (constant -> constant_bool .)
    GTHAN           reduce using rule 108 (constant -> constant_bool .)
    EQUAL           reduce using rule 108 (constant -> constant_bool .)
    NEQUAL          reduce using rule 108 (constant -> constant_bool .)
    AND             reduce using rule 108 (constant -> constant_bool .)
    SEMI            reduce using rule 108 (constant -> constant_bool .)
    OR              reduce using rule 108 (constant -> constant_bool .)
    RPAREN          reduce using rule 108 (constant -> constant_bool .)
    COMMA           reduce using rule 108 (constant -> constant_bool .)
    RBRACKET        reduce using rule 108 (constant -> constant_bool .)


state 101

    (109) constant_bool -> TRUE .

    TIMES           reduce using rule 109 (constant_bool -> TRUE .)
    DIVIDE          reduce using rule 109 (constant_bool -> TRUE .)
    MODULO          reduce using rule 109 (constant_bool -> TRUE .)
    PLUS            reduce using rule 109 (constant_bool -> TRUE .)
    MINUS           reduce using rule 109 (constant_bool -> TRUE .)
    LTHAN_EQUAL     reduce using rule 109 (constant_bool -> TRUE .)
    LTHAN           reduce using rule 109 (constant_bool -> TRUE .)
    GTHAN_EQUAL     reduce using rule 109 (constant_bool -> TRUE .)
    GTHAN           reduce using rule 109 (constant_bool -> TRUE .)
    EQUAL           reduce using rule 109 (constant_bool -> TRUE .)
    NEQUAL          reduce using rule 109 (constant_bool -> TRUE .)
    AND             reduce using rule 109 (constant_bool -> TRUE .)
    SEMI            reduce using rule 109 (constant_bool -> TRUE .)
    OR              reduce using rule 109 (constant_bool -> TRUE .)
    RPAREN          reduce using rule 109 (constant_bool -> TRUE .)
    COMMA           reduce using rule 109 (constant_bool -> TRUE .)
    RBRACKET        reduce using rule 109 (constant_bool -> TRUE .)


state 102

    (110) constant_bool -> FALSE .

    TIMES           reduce using rule 110 (constant_bool -> FALSE .)
    DIVIDE          reduce using rule 110 (constant_bool -> FALSE .)
    MODULO          reduce using rule 110 (constant_bool -> FALSE .)
    PLUS            reduce using rule 110 (constant_bool -> FALSE .)
    MINUS           reduce using rule 110 (constant_bool -> FALSE .)
    LTHAN_EQUAL     reduce using rule 110 (constant_bool -> FALSE .)
    LTHAN           reduce using rule 110 (constant_bool -> FALSE .)
    GTHAN_EQUAL     reduce using rule 110 (constant_bool -> FALSE .)
    GTHAN           reduce using rule 110 (constant_bool -> FALSE .)
    EQUAL           reduce using rule 110 (constant_bool -> FALSE .)
    NEQUAL          reduce using rule 110 (constant_bool -> FALSE .)
    AND             reduce using rule 110 (constant_bool -> FALSE .)
    SEMI            reduce using rule 110 (constant_bool -> FALSE .)
    OR              reduce using rule 110 (constant_bool -> FALSE .)
    RPAREN          reduce using rule 110 (constant_bool -> FALSE .)
    COMMA           reduce using rule 110 (constant_bool -> FALSE .)
    RBRACKET        reduce using rule 110 (constant_bool -> FALSE .)


state 103

    (73) while -> WHILE LPAREN . expr RPAREN instruction_block
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 148
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 104

    (74) for -> FROM LPAREN . ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM LPAREN . ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    ID              shift and go to state 149


state 105

    (24) single_function_definition_param -> type . ID

    ID              shift and go to state 150


state 106

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params . RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params . RPAREN instruction_block
    (22) function_definition_params -> function_definition_params . COMMA single_function_definition_param

    RPAREN          shift and go to state 151
    COMMA           shift and go to state 152


state 107

    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN . local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN . instruction_block
    (28) local_variables_declaration -> . LOCAL variables_declaration
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 153
    instruction_block              shift and go to state 154

state 108

    (23) function_definition_params -> single_function_definition_param .

    RPAREN          reduce using rule 23 (function_definition_params -> single_function_definition_param .)
    COMMA           reduce using rule 23 (function_definition_params -> single_function_definition_param .)


state 109

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params . RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params . RPAREN instruction_block
    (22) function_definition_params -> function_definition_params . COMMA single_function_definition_param

    RPAREN          shift and go to state 155
    COMMA           shift and go to state 152


state 110

    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN . local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN . instruction_block
    (28) local_variables_declaration -> . LOCAL variables_declaration
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 156
    instruction_block              shift and go to state 157

state 111

    (32) shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .

    INT             reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    REAL            reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    CHAR            reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    BOOL            reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    START           reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    FUNCTION        reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    LBRACE          reduce using rule 32 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)


state 112

    (34) shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA . single_variable_declaration
    (36) single_variable_declaration -> . ID dim_definition dim_definition
    (37) single_variable_declaration -> . ID dim_definition
    (38) single_variable_declaration -> . ID

    ID              shift and go to state 70

    single_variable_declaration    shift and go to state 158

state 113

    (36) single_variable_declaration -> ID dim_definition . dim_definition
    (37) single_variable_declaration -> ID dim_definition .
    (39) dim_definition -> . LBRACKET CONST_INT RBRACKET

    SEMI            reduce using rule 37 (single_variable_declaration -> ID dim_definition .)
    COMMA           reduce using rule 37 (single_variable_declaration -> ID dim_definition .)
    LBRACKET        shift and go to state 114

    dim_definition                 shift and go to state 159

state 114

    (39) dim_definition -> LBRACKET . CONST_INT RBRACKET

    CONST_INT       shift and go to state 160


state 115

    (51) assignment -> variable_access ASGMT expr . SEMI
    (78) expr -> expr . OR and_expr

    SEMI            shift and go to state 161
    OR              shift and go to state 131


state 116

    (52) assignment -> variable_access ASGMT read .

    RBRACE          reduce using rule 52 (assignment -> variable_access ASGMT read .)
    ID              reduce using rule 52 (assignment -> variable_access ASGMT read .)
    READ            reduce using rule 52 (assignment -> variable_access ASGMT read .)
    PRINT           reduce using rule 52 (assignment -> variable_access ASGMT read .)
    IF              reduce using rule 52 (assignment -> variable_access ASGMT read .)
    RETURN          reduce using rule 52 (assignment -> variable_access ASGMT read .)
    WHILE           reduce using rule 52 (assignment -> variable_access ASGMT read .)
    FROM            reduce using rule 52 (assignment -> variable_access ASGMT read .)


state 117

    (57) function_call -> ID LPAREN function_call_params . RPAREN SEMI
    (59) function_call_params -> function_call_params . COMMA single_function_call_param

    RPAREN          shift and go to state 162
    COMMA           shift and go to state 163


state 118

    (58) function_call -> ID LPAREN RPAREN . SEMI

    SEMI            shift and go to state 164


state 119

    (60) function_call_params -> single_function_call_param .

    RPAREN          reduce using rule 60 (function_call_params -> single_function_call_param .)
    COMMA           reduce using rule 60 (function_call_params -> single_function_call_param .)


state 120

    (61) single_function_call_param -> expr .
    (78) expr -> expr . OR and_expr

    RPAREN          reduce using rule 61 (single_function_call_param -> expr .)
    COMMA           reduce using rule 61 (single_function_call_param -> expr .)
    OR              shift and go to state 131


state 121

    (53) variable_access -> ID dim_access dim_access .

    ASGMT           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    TIMES           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    DIVIDE          reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    MODULO          reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    PLUS            reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    MINUS           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    LTHAN_EQUAL     reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    LTHAN           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    GTHAN_EQUAL     reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    GTHAN           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    EQUAL           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    NEQUAL          reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    AND             reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    SEMI            reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    OR              reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    RPAREN          reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    COMMA           reduce using rule 53 (variable_access -> ID dim_access dim_access .)
    RBRACKET        reduce using rule 53 (variable_access -> ID dim_access dim_access .)


state 122

    (56) dim_access -> LBRACKET expr . RBRACKET
    (78) expr -> expr . OR and_expr

    RBRACKET        shift and go to state 165
    OR              shift and go to state 131


state 123

    (62) read -> READ LPAREN RPAREN . SEMI

    SEMI            shift and go to state 166


state 124

    (63) print -> PRINT LPAREN print_params . RPAREN SEMI
    (65) print_params -> print_params . COMMA single_print_param

    RPAREN          shift and go to state 167
    COMMA           shift and go to state 168


state 125

    (64) print -> PRINT LPAREN RPAREN . SEMI

    SEMI            shift and go to state 169


state 126

    (66) print_params -> single_print_param .

    RPAREN          reduce using rule 66 (print_params -> single_print_param .)
    COMMA           reduce using rule 66 (print_params -> single_print_param .)


state 127

    (67) single_print_param -> expr .
    (78) expr -> expr . OR and_expr

    RPAREN          reduce using rule 67 (single_print_param -> expr .)
    COMMA           reduce using rule 67 (single_print_param -> expr .)
    OR              shift and go to state 131


state 128

    (68) single_print_param -> CONST_STRING .

    RPAREN          reduce using rule 68 (single_print_param -> CONST_STRING .)
    COMMA           reduce using rule 68 (single_print_param -> CONST_STRING .)


state 129

    (69) conditional -> IF LPAREN expr . RPAREN instruction_block ELSE instruction_block
    (70) conditional -> IF LPAREN expr . RPAREN instruction_block
    (78) expr -> expr . OR and_expr

    RPAREN          shift and go to state 170
    OR              shift and go to state 131


state 130

    (76) return -> RETURN expr SEMI .

    RBRACE          reduce using rule 76 (return -> RETURN expr SEMI .)
    ID              reduce using rule 76 (return -> RETURN expr SEMI .)
    READ            reduce using rule 76 (return -> RETURN expr SEMI .)
    PRINT           reduce using rule 76 (return -> RETURN expr SEMI .)
    IF              reduce using rule 76 (return -> RETURN expr SEMI .)
    RETURN          reduce using rule 76 (return -> RETURN expr SEMI .)
    WHILE           reduce using rule 76 (return -> RETURN expr SEMI .)
    FROM            reduce using rule 76 (return -> RETURN expr SEMI .)


state 131

    (78) expr -> expr OR . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    and_expr                       shift and go to state 171
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 132

    (80) and_expr -> equality_expr AND . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    equality_expr                  shift and go to state 172
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 133

    (82) equality_expr -> relational_expr EQUAL . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    relational_expr                shift and go to state 173
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 134

    (83) equality_expr -> relational_expr NEQUAL . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    relational_expr                shift and go to state 174
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 135

    (85) relational_expr -> additive_expr LTHAN_EQUAL . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 175
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 136

    (86) relational_expr -> additive_expr LTHAN . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 176
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 137

    (87) relational_expr -> additive_expr GTHAN_EQUAL . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 177
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 138

    (88) relational_expr -> additive_expr GTHAN . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 178
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 139

    (90) additive_expr -> multiplicative_expr PLUS . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    multiplicative_expr            shift and go to state 179
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 140

    (91) additive_expr -> multiplicative_expr MINUS . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    multiplicative_expr            shift and go to state 180
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 141

    (98) unary_expr -> PLUS postfix_expr .

    TIMES           reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    DIVIDE          reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    MODULO          reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    PLUS            reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    MINUS           reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    LTHAN_EQUAL     reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    LTHAN           reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    GTHAN_EQUAL     reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    GTHAN           reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    EQUAL           reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    NEQUAL          reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    AND             reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    SEMI            reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    OR              reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    RPAREN          reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    COMMA           reduce using rule 98 (unary_expr -> PLUS postfix_expr .)
    RBRACKET        reduce using rule 98 (unary_expr -> PLUS postfix_expr .)


state 142

    (97) unary_expr -> MINUS postfix_expr .

    TIMES           reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    DIVIDE          reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    MODULO          reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    PLUS            reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    MINUS           reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    LTHAN_EQUAL     reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    LTHAN           reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    GTHAN_EQUAL     reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    GTHAN           reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    EQUAL           reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    NEQUAL          reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    AND             reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    SEMI            reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    OR              reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    RPAREN          reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    COMMA           reduce using rule 97 (unary_expr -> MINUS postfix_expr .)
    RBRACKET        reduce using rule 97 (unary_expr -> MINUS postfix_expr .)


state 143

    (93) multiplicative_expr -> unary_expr TIMES . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    unary_expr                     shift and go to state 181
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 144

    (94) multiplicative_expr -> unary_expr DIVIDE . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    unary_expr                     shift and go to state 182
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 145

    (95) multiplicative_expr -> unary_expr MODULO . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    unary_expr                     shift and go to state 183
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 146

    (99) unary_expr -> NOT postfix_expr .

    TIMES           reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    DIVIDE          reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    MODULO          reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    PLUS            reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    MINUS           reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    LTHAN_EQUAL     reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    LTHAN           reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    GTHAN_EQUAL     reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    GTHAN           reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    EQUAL           reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    NEQUAL          reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    AND             reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    SEMI            reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    OR              reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    RPAREN          reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    COMMA           reduce using rule 99 (unary_expr -> NOT postfix_expr .)
    RBRACKET        reduce using rule 99 (unary_expr -> NOT postfix_expr .)


state 147

    (101) postfix_expr -> LPAREN expr . RPAREN
    (78) expr -> expr . OR and_expr

    RPAREN          shift and go to state 184
    OR              shift and go to state 131


state 148

    (73) while -> WHILE LPAREN expr . RPAREN instruction_block
    (78) expr -> expr . OR and_expr

    RPAREN          shift and go to state 185
    OR              shift and go to state 131


state 149

    (74) for -> FROM LPAREN ID . ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM LPAREN ID . ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    ASGMT           shift and go to state 186


state 150

    (24) single_function_definition_param -> type ID .

    RPAREN          reduce using rule 24 (single_function_definition_param -> type ID .)
    COMMA           reduce using rule 24 (single_function_definition_param -> type ID .)


state 151

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN . local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN . instruction_block
    (28) local_variables_declaration -> . LOCAL variables_declaration
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 187
    instruction_block              shift and go to state 188

state 152

    (22) function_definition_params -> function_definition_params COMMA . single_function_definition_param
    (24) single_function_definition_param -> . type ID
    (111) type -> . INT
    (112) type -> . REAL
    (113) type -> . CHAR
    (114) type -> . BOOL

    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    single_function_definition_param shift and go to state 189
    type                           shift and go to state 105

state 153

    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 190

state 154

    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block .

    START           reduce using rule 14 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block .)
    FUNCTION        reduce using rule 14 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN instruction_block .)


state 155

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN . local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN . instruction_block
    (28) local_variables_declaration -> . LOCAL variables_declaration
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 191
    instruction_block              shift and go to state 192

state 156

    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 193

state 157

    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block .

    START           reduce using rule 18 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block .)
    FUNCTION        reduce using rule 18 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN instruction_block .)


state 158

    (34) shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .

    SEMI            reduce using rule 34 (shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .)
    COMMA           reduce using rule 34 (shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .)


state 159

    (36) single_variable_declaration -> ID dim_definition dim_definition .

    SEMI            reduce using rule 36 (single_variable_declaration -> ID dim_definition dim_definition .)
    COMMA           reduce using rule 36 (single_variable_declaration -> ID dim_definition dim_definition .)


state 160

    (39) dim_definition -> LBRACKET CONST_INT . RBRACKET

    RBRACKET        shift and go to state 194


state 161

    (51) assignment -> variable_access ASGMT expr SEMI .

    RBRACE          reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    ID              reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    READ            reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    PRINT           reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    IF              reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    RETURN          reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    WHILE           reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    FROM            reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)


state 162

    (57) function_call -> ID LPAREN function_call_params RPAREN . SEMI

    SEMI            shift and go to state 195


state 163

    (59) function_call_params -> function_call_params COMMA . single_function_call_param
    (61) single_function_call_param -> . expr
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    single_function_call_param     shift and go to state 196
    expr                           shift and go to state 120
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 164

    (58) function_call -> ID LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    ID              reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    READ            reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    PRINT           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    IF              reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    WHILE           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    FROM            reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    TIMES           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    DIVIDE          reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    MODULO          reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    PLUS            reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    MINUS           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    LTHAN_EQUAL     reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    LTHAN           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    GTHAN_EQUAL     reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    GTHAN           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    EQUAL           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    NEQUAL          reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    AND             reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    SEMI            reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    OR              reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    RPAREN          reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    COMMA           reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)
    RBRACKET        reduce using rule 58 (function_call -> ID LPAREN RPAREN SEMI .)


state 165

    (56) dim_access -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    ASGMT           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    LTHAN_EQUAL     reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    LTHAN           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    GTHAN_EQUAL     reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    GTHAN           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    NEQUAL          reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 56 (dim_access -> LBRACKET expr RBRACKET .)


state 166

    (62) read -> READ LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    ID              reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    READ            reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    PRINT           reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    IF              reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    WHILE           reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)
    FROM            reduce using rule 62 (read -> READ LPAREN RPAREN SEMI .)


state 167

    (63) print -> PRINT LPAREN print_params RPAREN . SEMI

    SEMI            shift and go to state 197


state 168

    (65) print_params -> print_params COMMA . single_print_param
    (67) single_print_param -> . expr
    (68) single_print_param -> . CONST_STRING
    (78) expr -> . expr OR and_expr
    (79) expr -> . and_expr
    (80) and_expr -> . equality_expr AND equality_expr
    (81) and_expr -> . equality_expr
    (82) equality_expr -> . relational_expr EQUAL relational_expr
    (83) equality_expr -> . relational_expr NEQUAL relational_expr
    (84) equality_expr -> . relational_expr
    (85) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (86) relational_expr -> . additive_expr LTHAN additive_expr
    (87) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (88) relational_expr -> . additive_expr GTHAN additive_expr
    (89) relational_expr -> . additive_expr
    (90) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (91) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (92) additive_expr -> . multiplicative_expr
    (93) multiplicative_expr -> . unary_expr TIMES unary_expr
    (94) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (95) multiplicative_expr -> . unary_expr MODULO unary_expr
    (96) multiplicative_expr -> . unary_expr
    (97) unary_expr -> . MINUS postfix_expr
    (98) unary_expr -> . PLUS postfix_expr
    (99) unary_expr -> . NOT postfix_expr
    (100) unary_expr -> . postfix_expr
    (101) postfix_expr -> . LPAREN expr RPAREN
    (102) postfix_expr -> . variable_access
    (103) postfix_expr -> . function_call
    (104) postfix_expr -> . constant
    (53) variable_access -> . ID dim_access dim_access
    (54) variable_access -> . ID dim_access
    (55) variable_access -> . ID
    (57) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (58) function_call -> . ID LPAREN RPAREN SEMI
    (105) constant -> . CONST_INT
    (106) constant -> . CONST_REAL
    (107) constant -> . CONST_CHAR
    (108) constant -> . constant_bool
    (109) constant_bool -> . TRUE
    (110) constant_bool -> . FALSE

    CONST_STRING    shift and go to state 128
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    single_print_param             shift and go to state 198
    expr                           shift and go to state 127
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 169

    (64) print -> PRINT LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    ID              reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    READ            reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    PRINT           reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    IF              reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    WHILE           reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)
    FROM            reduce using rule 64 (print -> PRINT LPAREN RPAREN SEMI .)


state 170

    (69) conditional -> IF LPAREN expr RPAREN . instruction_block ELSE instruction_block
    (70) conditional -> IF LPAREN expr RPAREN . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 199

state 171

    (78) expr -> expr OR and_expr .

    SEMI            reduce using rule 78 (expr -> expr OR and_expr .)
    OR              reduce using rule 78 (expr -> expr OR and_expr .)
    RPAREN          reduce using rule 78 (expr -> expr OR and_expr .)
    COMMA           reduce using rule 78 (expr -> expr OR and_expr .)
    RBRACKET        reduce using rule 78 (expr -> expr OR and_expr .)


state 172

    (80) and_expr -> equality_expr AND equality_expr .

    SEMI            reduce using rule 80 (and_expr -> equality_expr AND equality_expr .)
    OR              reduce using rule 80 (and_expr -> equality_expr AND equality_expr .)
    RPAREN          reduce using rule 80 (and_expr -> equality_expr AND equality_expr .)
    COMMA           reduce using rule 80 (and_expr -> equality_expr AND equality_expr .)
    RBRACKET        reduce using rule 80 (and_expr -> equality_expr AND equality_expr .)


state 173

    (82) equality_expr -> relational_expr EQUAL relational_expr .

    AND             reduce using rule 82 (equality_expr -> relational_expr EQUAL relational_expr .)
    SEMI            reduce using rule 82 (equality_expr -> relational_expr EQUAL relational_expr .)
    OR              reduce using rule 82 (equality_expr -> relational_expr EQUAL relational_expr .)
    RPAREN          reduce using rule 82 (equality_expr -> relational_expr EQUAL relational_expr .)
    COMMA           reduce using rule 82 (equality_expr -> relational_expr EQUAL relational_expr .)
    RBRACKET        reduce using rule 82 (equality_expr -> relational_expr EQUAL relational_expr .)


state 174

    (83) equality_expr -> relational_expr NEQUAL relational_expr .

    AND             reduce using rule 83 (equality_expr -> relational_expr NEQUAL relational_expr .)
    SEMI            reduce using rule 83 (equality_expr -> relational_expr NEQUAL relational_expr .)
    OR              reduce using rule 83 (equality_expr -> relational_expr NEQUAL relational_expr .)
    RPAREN          reduce using rule 83 (equality_expr -> relational_expr NEQUAL relational_expr .)
    COMMA           reduce using rule 83 (equality_expr -> relational_expr NEQUAL relational_expr .)
    RBRACKET        reduce using rule 83 (equality_expr -> relational_expr NEQUAL relational_expr .)


state 175

    (85) relational_expr -> additive_expr LTHAN_EQUAL additive_expr .

    EQUAL           reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    NEQUAL          reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    AND             reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    SEMI            reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    OR              reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    RPAREN          reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    COMMA           reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    RBRACKET        reduce using rule 85 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)


state 176

    (86) relational_expr -> additive_expr LTHAN additive_expr .

    EQUAL           reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    NEQUAL          reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    AND             reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    SEMI            reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    OR              reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    RPAREN          reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    COMMA           reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)
    RBRACKET        reduce using rule 86 (relational_expr -> additive_expr LTHAN additive_expr .)


state 177

    (87) relational_expr -> additive_expr GTHAN_EQUAL additive_expr .

    EQUAL           reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    NEQUAL          reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    AND             reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    SEMI            reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    OR              reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    RPAREN          reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    COMMA           reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    RBRACKET        reduce using rule 87 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)


state 178

    (88) relational_expr -> additive_expr GTHAN additive_expr .

    EQUAL           reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    NEQUAL          reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    AND             reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    SEMI            reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    OR              reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    RPAREN          reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    COMMA           reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)
    RBRACKET        reduce using rule 88 (relational_expr -> additive_expr GTHAN additive_expr .)


state 179

    (90) additive_expr -> multiplicative_expr PLUS multiplicative_expr .

    LTHAN_EQUAL     reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    LTHAN           reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    GTHAN           reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    EQUAL           reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    NEQUAL          reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    AND             reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    SEMI            reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    OR              reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    RPAREN          reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    COMMA           reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    RBRACKET        reduce using rule 90 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)


state 180

    (91) additive_expr -> multiplicative_expr MINUS multiplicative_expr .

    LTHAN_EQUAL     reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    LTHAN           reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    GTHAN           reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    EQUAL           reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    NEQUAL          reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    AND             reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    SEMI            reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    OR              reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    RPAREN          reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    COMMA           reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    RBRACKET        reduce using rule 91 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)


state 181

    (93) multiplicative_expr -> unary_expr TIMES unary_expr .

    PLUS            reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    MINUS           reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    LTHAN_EQUAL     reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    LTHAN           reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    GTHAN_EQUAL     reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    GTHAN           reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    EQUAL           reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    NEQUAL          reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    AND             reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    SEMI            reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    OR              reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    RPAREN          reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    COMMA           reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    RBRACKET        reduce using rule 93 (multiplicative_expr -> unary_expr TIMES unary_expr .)


state 182

    (94) multiplicative_expr -> unary_expr DIVIDE unary_expr .

    PLUS            reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    MINUS           reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    LTHAN_EQUAL     reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    LTHAN           reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    GTHAN_EQUAL     reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    GTHAN           reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    EQUAL           reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    NEQUAL          reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    AND             reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    SEMI            reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    OR              reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    RPAREN          reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    COMMA           reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    RBRACKET        reduce using rule 94 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)


state 183

    (95) multiplicative_expr -> unary_expr MODULO unary_expr .

    PLUS            reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    MINUS           reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    LTHAN_EQUAL     reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    LTHAN           reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    GTHAN_EQUAL     reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    GTHAN           reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    EQUAL           reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    NEQUAL          reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    AND             reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    SEMI            reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    OR              reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    RPAREN          reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    COMMA           reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    RBRACKET        reduce using rule 95 (multiplicative_expr -> unary_expr MODULO unary_expr .)


state 184

    (101) postfix_expr -> LPAREN expr RPAREN .

    TIMES           reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    MODULO          reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    LTHAN_EQUAL     reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    LTHAN           reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    GTHAN_EQUAL     reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    GTHAN           reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    NEQUAL          reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 101 (postfix_expr -> LPAREN expr RPAREN .)


state 185

    (73) while -> WHILE LPAREN expr RPAREN . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 200

state 186

    (74) for -> FROM LPAREN ID ASGMT . CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM LPAREN ID ASGMT . CONST_INT COLON CONST_INT RPAREN instruction_block

    CONST_INT       shift and go to state 201


state 187

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 202

state 188

    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block .

    START           reduce using rule 12 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block .)
    FUNCTION        reduce using rule 12 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block .)


state 189

    (22) function_definition_params -> function_definition_params COMMA single_function_definition_param .

    RPAREN          reduce using rule 22 (function_definition_params -> function_definition_params COMMA single_function_definition_param .)
    COMMA           reduce using rule 22 (function_definition_params -> function_definition_params COMMA single_function_definition_param .)


state 190

    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 13 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 13 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block .)


state 191

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 203

state 192

    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block .

    START           reduce using rule 16 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block .)
    FUNCTION        reduce using rule 16 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN instruction_block .)


state 193

    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 17 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 17 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN RPAREN local_variables_declaration instruction_block .)


state 194

    (39) dim_definition -> LBRACKET CONST_INT RBRACKET .

    LBRACKET        reduce using rule 39 (dim_definition -> LBRACKET CONST_INT RBRACKET .)
    SEMI            reduce using rule 39 (dim_definition -> LBRACKET CONST_INT RBRACKET .)
    COMMA           reduce using rule 39 (dim_definition -> LBRACKET CONST_INT RBRACKET .)


state 195

    (57) function_call -> ID LPAREN function_call_params RPAREN SEMI .

    RBRACE          reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    ID              reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    READ            reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    PRINT           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    IF              reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    RETURN          reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    WHILE           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    FROM            reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    TIMES           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    DIVIDE          reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    MODULO          reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    PLUS            reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    MINUS           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    LTHAN_EQUAL     reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    LTHAN           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    GTHAN_EQUAL     reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    GTHAN           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    EQUAL           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    NEQUAL          reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    AND             reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    SEMI            reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    OR              reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    RPAREN          reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    COMMA           reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    RBRACKET        reduce using rule 57 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)


state 196

    (59) function_call_params -> function_call_params COMMA single_function_call_param .

    RPAREN          reduce using rule 59 (function_call_params -> function_call_params COMMA single_function_call_param .)
    COMMA           reduce using rule 59 (function_call_params -> function_call_params COMMA single_function_call_param .)


state 197

    (63) print -> PRINT LPAREN print_params RPAREN SEMI .

    RBRACE          reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    ID              reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    READ            reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    PRINT           reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    IF              reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    RETURN          reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    WHILE           reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    FROM            reduce using rule 63 (print -> PRINT LPAREN print_params RPAREN SEMI .)


state 198

    (65) print_params -> print_params COMMA single_print_param .

    RPAREN          reduce using rule 65 (print_params -> print_params COMMA single_print_param .)
    COMMA           reduce using rule 65 (print_params -> print_params COMMA single_print_param .)


state 199

    (69) conditional -> IF LPAREN expr RPAREN instruction_block . ELSE instruction_block
    (70) conditional -> IF LPAREN expr RPAREN instruction_block .

    ELSE            shift and go to state 204
    RBRACE          reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    ID              reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    READ            reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    PRINT           reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    IF              reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    RETURN          reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    WHILE           reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)
    FROM            reduce using rule 70 (conditional -> IF LPAREN expr RPAREN instruction_block .)


state 200

    (73) while -> WHILE LPAREN expr RPAREN instruction_block .

    RBRACE          reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    ID              reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    READ            reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    PRINT           reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    IF              reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    RETURN          reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    WHILE           reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)
    FROM            reduce using rule 73 (while -> WHILE LPAREN expr RPAREN instruction_block .)


state 201

    (74) for -> FROM LPAREN ID ASGMT CONST_INT . COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM LPAREN ID ASGMT CONST_INT . COLON CONST_INT RPAREN instruction_block

    COLON           shift and go to state 205


state 202

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 11 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 11 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)


state 203

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 15 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 15 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)


state 204

    (69) conditional -> IF LPAREN expr RPAREN instruction_block ELSE . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 206

state 205

    (74) for -> FROM LPAREN ID ASGMT CONST_INT COLON . CONST_INT COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM LPAREN ID ASGMT CONST_INT COLON . CONST_INT RPAREN instruction_block

    CONST_INT       shift and go to state 207


state 206

    (69) conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .

    RBRACE          reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    ID              reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    READ            reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    PRINT           reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    IF              reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    RETURN          reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    WHILE           reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)
    FROM            reduce using rule 69 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)


state 207

    (74) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT . COLON CONST_INT RPAREN instruction_block
    (75) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT . RPAREN instruction_block

    COLON           shift and go to state 208
    RPAREN          shift and go to state 209


state 208

    (74) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON . CONST_INT RPAREN instruction_block

    CONST_INT       shift and go to state 210


state 209

    (75) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 211

state 210

    (74) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT . RPAREN instruction_block

    RPAREN          shift and go to state 212


state 211

    (75) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .

    RBRACE          reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    ID              reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    READ            reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    PRINT           reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    IF              reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    RETURN          reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    WHILE           reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)
    FROM            reduce using rule 75 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)


state 212

    (74) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN . instruction_block
    (40) instruction_block -> . LBRACE statements RBRACE
    (41) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 213

state 213

    (74) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .

    RBRACE          reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    ID              reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    READ            reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    PRINT           reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    IF              reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    RETURN          reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    WHILE           reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)
    FROM            reduce using rule 74 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)

