Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> global_variables_declaration functions_definition entry_point_definition
Rule 2     start -> global_variables_declaration entry_point_definition
Rule 3     start -> functions_definition entry_point_definition
Rule 4     start -> entry_point_definition
Rule 5     global_variables_declaration -> GLOBAL variables_declaration
Rule 6     functions_definition -> functions_definition single_function_definition
Rule 7     functions_definition -> single_function_definition
Rule 8     single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
Rule 9     single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block
Rule 10    single_function_definition -> FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block
Rule 11    single_function_definition -> FUNCTION type ID LPAREN RPAREN instruction_block
Rule 12    single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
Rule 13    single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block
Rule 14    single_function_definition -> FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block
Rule 15    single_function_definition -> FUNCTION VOID ID LPAREN RPAREN instruction_block
Rule 16    function_definition_params -> function_definition_params COMMA single_function_definition_param
Rule 17    function_definition_params -> single_function_definition_param
Rule 18    single_function_definition_param -> type ID
Rule 19    entry_point_definition -> START LPAREN RPAREN local_variables_declaration instruction_block
Rule 20    entry_point_definition -> START LPAREN RPAREN instruction_block
Rule 21    local_variables_declaration -> LOCAL variables_declaration
Rule 22    variables_declaration -> VARIABLES COLON distinct_type_variables_declaration
Rule 23    distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration
Rule 24    distinct_type_variables_declaration -> shared_type_variables_declaration
Rule 25    shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI
Rule 26    shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration
Rule 27    shared_type_variables_declaration_list -> single_variable_declaration
Rule 28    single_variable_declaration -> ID dim_definition dim_definition
Rule 29    single_variable_declaration -> ID dim_definition
Rule 30    single_variable_declaration -> ID
Rule 31    dim_definition -> LBRACKET CONST_INT RBRACKET
Rule 32    instruction_block -> LBRACE statements RBRACE
Rule 33    instruction_block -> LBRACE RBRACE
Rule 34    statements -> single_statement
Rule 35    single_statement -> assignment
Rule 36    single_statement -> function_call
Rule 37    single_statement -> read
Rule 38    single_statement -> print
Rule 39    single_statement -> conditional
Rule 40    single_statement -> loop
Rule 41    single_statement -> return
Rule 42    assignment -> variable_access ASGMT expr SEMI
Rule 43    assignment -> variable_access ASGMT read
Rule 44    variable_access -> ID dim_access dim_access
Rule 45    variable_access -> ID dim_access
Rule 46    variable_access -> ID
Rule 47    dim_access -> LBRACKET expr RBRACKET
Rule 48    function_call -> ID LPAREN function_call_params RPAREN SEMI
Rule 49    function_call -> ID LPAREN RPAREN SEMI
Rule 50    function_call_params -> function_call_params COMMA single_function_call_param
Rule 51    function_call_params -> single_function_call_param
Rule 52    single_function_call_param -> expr
Rule 53    read -> READ LPAREN RPAREN SEMI
Rule 54    print -> PRINT LPAREN print_params RPAREN SEMI
Rule 55    print -> PRINT LPAREN RPAREN SEMI
Rule 56    print_params -> print_params COMMA single_print_param
Rule 57    print_params -> single_print_param
Rule 58    single_print_param -> expr
Rule 59    single_print_param -> CONST_STRING
Rule 60    conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block
Rule 61    conditional -> IF LPAREN expr RPAREN instruction_block
Rule 62    loop -> while
Rule 63    loop -> for
Rule 64    while -> WHILE LPAREN expr RPAREN instruction_block
Rule 65    for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
Rule 66    for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block
Rule 67    return -> RETURN expr SEMI
Rule 68    return -> RETURN SEMI
Rule 69    expr -> expr OR and_expr
Rule 70    expr -> and_expr
Rule 71    and_expr -> equality_expr AND equality_expr
Rule 72    and_expr -> equality_expr
Rule 73    equality_expr -> relational_expr EQUAL relational_expr
Rule 74    equality_expr -> relational_expr NEQUAL relational_expr
Rule 75    equality_expr -> relational_expr
Rule 76    relational_expr -> additive_expr LTHAN_EQUAL additive_expr
Rule 77    relational_expr -> additive_expr LTHAN additive_expr
Rule 78    relational_expr -> additive_expr GTHAN_EQUAL additive_expr
Rule 79    relational_expr -> additive_expr GTHAN additive_expr
Rule 80    relational_expr -> additive_expr
Rule 81    additive_expr -> multiplicative_expr PLUS multiplicative_expr
Rule 82    additive_expr -> multiplicative_expr MINUS multiplicative_expr
Rule 83    additive_expr -> multiplicative_expr
Rule 84    multiplicative_expr -> unary_expr TIMES unary_expr
Rule 85    multiplicative_expr -> unary_expr DIVIDE unary_expr
Rule 86    multiplicative_expr -> unary_expr MODULO unary_expr
Rule 87    multiplicative_expr -> unary_expr
Rule 88    unary_expr -> MINUS postfix_expr
Rule 89    unary_expr -> PLUS postfix_expr
Rule 90    unary_expr -> NOT postfix_expr
Rule 91    unary_expr -> postfix_expr
Rule 92    postfix_expr -> LPAREN expr RPAREN
Rule 93    postfix_expr -> variable_access
Rule 94    postfix_expr -> function_call
Rule 95    postfix_expr -> constant
Rule 96    constant -> CONST_INT
Rule 97    constant -> CONST_REAL
Rule 98    constant -> CONST_CHAR
Rule 99    constant -> constant_bool
Rule 100   constant_bool -> TRUE
Rule 101   constant_bool -> FALSE
Rule 102   type -> INT
Rule 103   type -> REAL
Rule 104   type -> CHAR
Rule 105   type -> BOOL

Terminals, with rules where they appear

AND                  : 71
ASGMT                : 42 43 65 66
BOOL                 : 105
CHAR                 : 104
COLON                : 22 65 65 66
COMMA                : 16 26 50 56
CONST_CHAR           : 98
CONST_INT            : 31 65 65 65 66 66 96
CONST_REAL           : 97
CONST_STRING         : 59
DIVIDE               : 85
ELSE                 : 60
EQUAL                : 73
FALSE                : 101
FROM                 : 65 66
FUNCTION             : 8 9 10 11 12 13 14 15
GLOBAL               : 5
GTHAN                : 79
GTHAN_EQUAL          : 78
ID                   : 8 9 10 11 12 13 14 15 18 28 29 30 44 45 46 48 49 65 66
IF                   : 60 61
INT                  : 102
LBRACE               : 32 33
LBRACKET             : 31 47
LOCAL                : 21
LPAREN               : 8 9 10 11 12 13 14 15 19 20 48 49 53 54 55 60 61 64 65 66 92
LTHAN                : 77
LTHAN_EQUAL          : 76
MINUS                : 82 88
MODULO               : 86
NEQUAL               : 74
NOT                  : 90
OR                   : 69
PLUS                 : 81 89
PRINT                : 54 55
RBRACE               : 32 33
RBRACKET             : 31 47
READ                 : 53
REAL                 : 103
RETURN               : 67 68
RPAREN               : 8 9 10 11 12 13 14 15 19 20 48 49 53 54 55 60 61 64 65 66 92
SEMI                 : 25 42 48 49 53 54 55 67 68
START                : 19 20
TIMES                : 84
TRUE                 : 100
VARIABLES            : 22
VOID                 : 12 13 14 15
WHILE                : 64
error                : 

Nonterminals, with rules where they appear

additive_expr        : 76 76 77 77 78 78 79 79 80
and_expr             : 69 70
assignment           : 35
conditional          : 39
constant             : 95
constant_bool        : 99
dim_access           : 44 44 45
dim_definition       : 28 28 29
distinct_type_variables_declaration : 22 23
entry_point_definition : 1 2 3 4
equality_expr        : 71 71 72
expr                 : 42 47 52 58 60 61 64 67 69 92
for                  : 63
function_call        : 36 94
function_call_params : 48 50
function_definition_params : 8 9 12 13 16
functions_definition : 1 3 6
global_variables_declaration : 1 2
instruction_block    : 8 9 10 11 12 13 14 15 19 20 60 60 61 64 65 66
local_variables_declaration : 8 10 12 14 19
loop                 : 40
multiplicative_expr  : 81 81 82 82 83
postfix_expr         : 88 89 90 91
print                : 38
print_params         : 54 56
read                 : 37 43
relational_expr      : 73 73 74 74 75
return               : 41
shared_type_variables_declaration : 23 24
shared_type_variables_declaration_list : 25 26
single_function_call_param : 50 51
single_function_definition : 6 7
single_function_definition_param : 16 17
single_print_param   : 56 57
single_statement     : 34
single_variable_declaration : 26 27
start                : 0
statements           : 32
type                 : 8 9 10 11 18 25
unary_expr           : 84 84 85 85 86 86 87
variable_access      : 42 43 93
variables_declaration : 5 21
while                : 62

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . global_variables_declaration functions_definition entry_point_definition
    (2) start -> . global_variables_declaration entry_point_definition
    (3) start -> . functions_definition entry_point_definition
    (4) start -> . entry_point_definition
    (5) global_variables_declaration -> . GLOBAL variables_declaration
    (6) functions_definition -> . functions_definition single_function_definition
    (7) functions_definition -> . single_function_definition
    (19) entry_point_definition -> . START LPAREN RPAREN local_variables_declaration instruction_block
    (20) entry_point_definition -> . START LPAREN RPAREN instruction_block
    (8) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> . FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> . FUNCTION type ID LPAREN RPAREN instruction_block
    (12) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN instruction_block

    GLOBAL          shift and go to state 5
    START           shift and go to state 7
    FUNCTION        shift and go to state 8

    start                          shift and go to state 1
    global_variables_declaration   shift and go to state 2
    functions_definition           shift and go to state 3
    entry_point_definition         shift and go to state 4
    single_function_definition     shift and go to state 6

state 1

    (0) S' -> start .



state 2

    (1) start -> global_variables_declaration . functions_definition entry_point_definition
    (2) start -> global_variables_declaration . entry_point_definition
    (6) functions_definition -> . functions_definition single_function_definition
    (7) functions_definition -> . single_function_definition
    (19) entry_point_definition -> . START LPAREN RPAREN local_variables_declaration instruction_block
    (20) entry_point_definition -> . START LPAREN RPAREN instruction_block
    (8) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> . FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> . FUNCTION type ID LPAREN RPAREN instruction_block
    (12) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN instruction_block

    START           shift and go to state 7
    FUNCTION        shift and go to state 8

    functions_definition           shift and go to state 9
    entry_point_definition         shift and go to state 10
    single_function_definition     shift and go to state 6

state 3

    (3) start -> functions_definition . entry_point_definition
    (6) functions_definition -> functions_definition . single_function_definition
    (19) entry_point_definition -> . START LPAREN RPAREN local_variables_declaration instruction_block
    (20) entry_point_definition -> . START LPAREN RPAREN instruction_block
    (8) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> . FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> . FUNCTION type ID LPAREN RPAREN instruction_block
    (12) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN instruction_block

    START           shift and go to state 7
    FUNCTION        shift and go to state 8

    entry_point_definition         shift and go to state 11
    single_function_definition     shift and go to state 12

state 4

    (4) start -> entry_point_definition .

    $end            reduce using rule 4 (start -> entry_point_definition .)


state 5

    (5) global_variables_declaration -> GLOBAL . variables_declaration
    (22) variables_declaration -> . VARIABLES COLON distinct_type_variables_declaration

    VARIABLES       shift and go to state 14

    variables_declaration          shift and go to state 13

state 6

    (7) functions_definition -> single_function_definition .

    START           reduce using rule 7 (functions_definition -> single_function_definition .)
    FUNCTION        reduce using rule 7 (functions_definition -> single_function_definition .)


state 7

    (19) entry_point_definition -> START . LPAREN RPAREN local_variables_declaration instruction_block
    (20) entry_point_definition -> START . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 15


state 8

    (8) single_function_definition -> FUNCTION . type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> FUNCTION . type ID LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> FUNCTION . type ID LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> FUNCTION . type ID LPAREN RPAREN instruction_block
    (12) single_function_definition -> FUNCTION . VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> FUNCTION . VOID ID LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> FUNCTION . VOID ID LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> FUNCTION . VOID ID LPAREN RPAREN instruction_block
    (102) type -> . INT
    (103) type -> . REAL
    (104) type -> . CHAR
    (105) type -> . BOOL

    VOID            shift and go to state 17
    INT             shift and go to state 18
    REAL            shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21

    type                           shift and go to state 16

state 9

    (1) start -> global_variables_declaration functions_definition . entry_point_definition
    (6) functions_definition -> functions_definition . single_function_definition
    (19) entry_point_definition -> . START LPAREN RPAREN local_variables_declaration instruction_block
    (20) entry_point_definition -> . START LPAREN RPAREN instruction_block
    (8) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> . FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> . FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> . FUNCTION type ID LPAREN RPAREN instruction_block
    (12) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> . FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> . FUNCTION VOID ID LPAREN RPAREN instruction_block

    START           shift and go to state 7
    FUNCTION        shift and go to state 8

    entry_point_definition         shift and go to state 22
    single_function_definition     shift and go to state 12

state 10

    (2) start -> global_variables_declaration entry_point_definition .

    $end            reduce using rule 2 (start -> global_variables_declaration entry_point_definition .)


state 11

    (3) start -> functions_definition entry_point_definition .

    $end            reduce using rule 3 (start -> functions_definition entry_point_definition .)


state 12

    (6) functions_definition -> functions_definition single_function_definition .

    START           reduce using rule 6 (functions_definition -> functions_definition single_function_definition .)
    FUNCTION        reduce using rule 6 (functions_definition -> functions_definition single_function_definition .)


state 13

    (5) global_variables_declaration -> GLOBAL variables_declaration .

    START           reduce using rule 5 (global_variables_declaration -> GLOBAL variables_declaration .)
    FUNCTION        reduce using rule 5 (global_variables_declaration -> GLOBAL variables_declaration .)


state 14

    (22) variables_declaration -> VARIABLES . COLON distinct_type_variables_declaration

    COLON           shift and go to state 23


state 15

    (19) entry_point_definition -> START LPAREN . RPAREN local_variables_declaration instruction_block
    (20) entry_point_definition -> START LPAREN . RPAREN instruction_block

    RPAREN          shift and go to state 24


state 16

    (8) single_function_definition -> FUNCTION type . ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> FUNCTION type . ID LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> FUNCTION type . ID LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> FUNCTION type . ID LPAREN RPAREN instruction_block

    ID              shift and go to state 25


state 17

    (12) single_function_definition -> FUNCTION VOID . ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> FUNCTION VOID . ID LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> FUNCTION VOID . ID LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> FUNCTION VOID . ID LPAREN RPAREN instruction_block

    ID              shift and go to state 26


state 18

    (102) type -> INT .

    ID              reduce using rule 102 (type -> INT .)


state 19

    (103) type -> REAL .

    ID              reduce using rule 103 (type -> REAL .)


state 20

    (104) type -> CHAR .

    ID              reduce using rule 104 (type -> CHAR .)


state 21

    (105) type -> BOOL .

    ID              reduce using rule 105 (type -> BOOL .)


state 22

    (1) start -> global_variables_declaration functions_definition entry_point_definition .

    $end            reduce using rule 1 (start -> global_variables_declaration functions_definition entry_point_definition .)


state 23

    (22) variables_declaration -> VARIABLES COLON . distinct_type_variables_declaration
    (23) distinct_type_variables_declaration -> . distinct_type_variables_declaration shared_type_variables_declaration
    (24) distinct_type_variables_declaration -> . shared_type_variables_declaration
    (25) shared_type_variables_declaration -> . type shared_type_variables_declaration_list SEMI
    (102) type -> . INT
    (103) type -> . REAL
    (104) type -> . CHAR
    (105) type -> . BOOL

    INT             shift and go to state 18
    REAL            shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21

    distinct_type_variables_declaration shift and go to state 27
    shared_type_variables_declaration shift and go to state 28
    type                           shift and go to state 29

state 24

    (19) entry_point_definition -> START LPAREN RPAREN . local_variables_declaration instruction_block
    (20) entry_point_definition -> START LPAREN RPAREN . instruction_block
    (21) local_variables_declaration -> . LOCAL variables_declaration
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 32
    LBRACE          shift and go to state 33

    local_variables_declaration    shift and go to state 30
    instruction_block              shift and go to state 31

state 25

    (8) single_function_definition -> FUNCTION type ID . LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> FUNCTION type ID . LPAREN function_definition_params RPAREN instruction_block
    (10) single_function_definition -> FUNCTION type ID . LPAREN RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> FUNCTION type ID . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 34


state 26

    (12) single_function_definition -> FUNCTION VOID ID . LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> FUNCTION VOID ID . LPAREN function_definition_params RPAREN instruction_block
    (14) single_function_definition -> FUNCTION VOID ID . LPAREN RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> FUNCTION VOID ID . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 35


state 27

    (22) variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .
    (23) distinct_type_variables_declaration -> distinct_type_variables_declaration . shared_type_variables_declaration
    (25) shared_type_variables_declaration -> . type shared_type_variables_declaration_list SEMI
    (102) type -> . INT
    (103) type -> . REAL
    (104) type -> . CHAR
    (105) type -> . BOOL

    START           reduce using rule 22 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    FUNCTION        reduce using rule 22 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    LBRACE          reduce using rule 22 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    INT             shift and go to state 18
    REAL            shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21

    shared_type_variables_declaration shift and go to state 36
    type                           shift and go to state 29

state 28

    (24) distinct_type_variables_declaration -> shared_type_variables_declaration .

    INT             reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    REAL            reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    CHAR            reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    BOOL            reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    START           reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    FUNCTION        reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    LBRACE          reduce using rule 24 (distinct_type_variables_declaration -> shared_type_variables_declaration .)


state 29

    (25) shared_type_variables_declaration -> type . shared_type_variables_declaration_list SEMI
    (26) shared_type_variables_declaration_list -> . shared_type_variables_declaration_list COMMA single_variable_declaration
    (27) shared_type_variables_declaration_list -> . single_variable_declaration
    (28) single_variable_declaration -> . ID dim_definition dim_definition
    (29) single_variable_declaration -> . ID dim_definition
    (30) single_variable_declaration -> . ID

    ID              shift and go to state 39

    shared_type_variables_declaration_list shift and go to state 37
    single_variable_declaration    shift and go to state 38

state 30

    (19) entry_point_definition -> START LPAREN RPAREN local_variables_declaration . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 40

state 31

    (20) entry_point_definition -> START LPAREN RPAREN instruction_block .

    $end            reduce using rule 20 (entry_point_definition -> START LPAREN RPAREN instruction_block .)


state 32

    (21) local_variables_declaration -> LOCAL . variables_declaration
    (22) variables_declaration -> . VARIABLES COLON distinct_type_variables_declaration

    VARIABLES       shift and go to state 14

    variables_declaration          shift and go to state 41

state 33

    (32) instruction_block -> LBRACE . statements RBRACE
    (33) instruction_block -> LBRACE . RBRACE
    (34) statements -> . single_statement
    (35) single_statement -> . assignment
    (36) single_statement -> . function_call
    (37) single_statement -> . read
    (38) single_statement -> . print
    (39) single_statement -> . conditional
    (40) single_statement -> . loop
    (41) single_statement -> . return
    (42) assignment -> . variable_access ASGMT expr SEMI
    (43) assignment -> . variable_access ASGMT read
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (53) read -> . READ LPAREN RPAREN SEMI
    (54) print -> . PRINT LPAREN print_params RPAREN SEMI
    (55) print -> . PRINT LPAREN RPAREN SEMI
    (60) conditional -> . IF LPAREN expr RPAREN instruction_block ELSE instruction_block
    (61) conditional -> . IF LPAREN expr RPAREN instruction_block
    (62) loop -> . while
    (63) loop -> . for
    (67) return -> . RETURN expr SEMI
    (68) return -> . RETURN SEMI
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (64) while -> . WHILE LPAREN expr RPAREN instruction_block
    (65) for -> . FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> . FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    RBRACE          shift and go to state 43
    ID              shift and go to state 53
    READ            shift and go to state 54
    PRINT           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 59
    WHILE           shift and go to state 60
    FROM            shift and go to state 61

    statements                     shift and go to state 42
    single_statement               shift and go to state 44
    assignment                     shift and go to state 45
    function_call                  shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    return                         shift and go to state 51
    variable_access                shift and go to state 52
    while                          shift and go to state 57
    for                            shift and go to state 58

state 34

    (8) single_function_definition -> FUNCTION type ID LPAREN . function_definition_params RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> FUNCTION type ID LPAREN . function_definition_params RPAREN instruction_block
    (10) single_function_definition -> FUNCTION type ID LPAREN . RPAREN local_variables_declaration instruction_block
    (11) single_function_definition -> FUNCTION type ID LPAREN . RPAREN instruction_block
    (16) function_definition_params -> . function_definition_params COMMA single_function_definition_param
    (17) function_definition_params -> . single_function_definition_param
    (18) single_function_definition_param -> . type ID
    (102) type -> . INT
    (103) type -> . REAL
    (104) type -> . CHAR
    (105) type -> . BOOL

    RPAREN          shift and go to state 64
    INT             shift and go to state 18
    REAL            shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21

    type                           shift and go to state 62
    function_definition_params     shift and go to state 63
    single_function_definition_param shift and go to state 65

state 35

    (12) single_function_definition -> FUNCTION VOID ID LPAREN . function_definition_params RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> FUNCTION VOID ID LPAREN . function_definition_params RPAREN instruction_block
    (14) single_function_definition -> FUNCTION VOID ID LPAREN . RPAREN local_variables_declaration instruction_block
    (15) single_function_definition -> FUNCTION VOID ID LPAREN . RPAREN instruction_block
    (16) function_definition_params -> . function_definition_params COMMA single_function_definition_param
    (17) function_definition_params -> . single_function_definition_param
    (18) single_function_definition_param -> . type ID
    (102) type -> . INT
    (103) type -> . REAL
    (104) type -> . CHAR
    (105) type -> . BOOL

    RPAREN          shift and go to state 67
    INT             shift and go to state 18
    REAL            shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21

    function_definition_params     shift and go to state 66
    single_function_definition_param shift and go to state 65
    type                           shift and go to state 62

state 36

    (23) distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .

    INT             reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    REAL            reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    CHAR            reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    BOOL            reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    START           reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    FUNCTION        reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    LBRACE          reduce using rule 23 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)


state 37

    (25) shared_type_variables_declaration -> type shared_type_variables_declaration_list . SEMI
    (26) shared_type_variables_declaration_list -> shared_type_variables_declaration_list . COMMA single_variable_declaration

    SEMI            shift and go to state 68
    COMMA           shift and go to state 69


state 38

    (27) shared_type_variables_declaration_list -> single_variable_declaration .

    SEMI            reduce using rule 27 (shared_type_variables_declaration_list -> single_variable_declaration .)
    COMMA           reduce using rule 27 (shared_type_variables_declaration_list -> single_variable_declaration .)


state 39

    (28) single_variable_declaration -> ID . dim_definition dim_definition
    (29) single_variable_declaration -> ID . dim_definition
    (30) single_variable_declaration -> ID .
    (31) dim_definition -> . LBRACKET CONST_INT RBRACKET

    SEMI            reduce using rule 30 (single_variable_declaration -> ID .)
    COMMA           reduce using rule 30 (single_variable_declaration -> ID .)
    LBRACKET        shift and go to state 71

    dim_definition                 shift and go to state 70

state 40

    (19) entry_point_definition -> START LPAREN RPAREN local_variables_declaration instruction_block .

    $end            reduce using rule 19 (entry_point_definition -> START LPAREN RPAREN local_variables_declaration instruction_block .)


state 41

    (21) local_variables_declaration -> LOCAL variables_declaration .

    LBRACE          reduce using rule 21 (local_variables_declaration -> LOCAL variables_declaration .)


state 42

    (32) instruction_block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 72


state 43

    (33) instruction_block -> LBRACE RBRACE .

    $end            reduce using rule 33 (instruction_block -> LBRACE RBRACE .)
    START           reduce using rule 33 (instruction_block -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 33 (instruction_block -> LBRACE RBRACE .)
    ELSE            reduce using rule 33 (instruction_block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 33 (instruction_block -> LBRACE RBRACE .)


state 44

    (34) statements -> single_statement .

    RBRACE          reduce using rule 34 (statements -> single_statement .)


state 45

    (35) single_statement -> assignment .

    RBRACE          reduce using rule 35 (single_statement -> assignment .)


state 46

    (36) single_statement -> function_call .

    RBRACE          reduce using rule 36 (single_statement -> function_call .)


state 47

    (37) single_statement -> read .

    RBRACE          reduce using rule 37 (single_statement -> read .)


state 48

    (38) single_statement -> print .

    RBRACE          reduce using rule 38 (single_statement -> print .)


state 49

    (39) single_statement -> conditional .

    RBRACE          reduce using rule 39 (single_statement -> conditional .)


state 50

    (40) single_statement -> loop .

    RBRACE          reduce using rule 40 (single_statement -> loop .)


state 51

    (41) single_statement -> return .

    RBRACE          reduce using rule 41 (single_statement -> return .)


state 52

    (42) assignment -> variable_access . ASGMT expr SEMI
    (43) assignment -> variable_access . ASGMT read

    ASGMT           shift and go to state 73


state 53

    (48) function_call -> ID . LPAREN function_call_params RPAREN SEMI
    (49) function_call -> ID . LPAREN RPAREN SEMI
    (44) variable_access -> ID . dim_access dim_access
    (45) variable_access -> ID . dim_access
    (46) variable_access -> ID .
    (47) dim_access -> . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 74
    ASGMT           reduce using rule 46 (variable_access -> ID .)
    LBRACKET        shift and go to state 76

    dim_access                     shift and go to state 75

state 54

    (53) read -> READ . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 77


state 55

    (54) print -> PRINT . LPAREN print_params RPAREN SEMI
    (55) print -> PRINT . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 78


state 56

    (60) conditional -> IF . LPAREN expr RPAREN instruction_block ELSE instruction_block
    (61) conditional -> IF . LPAREN expr RPAREN instruction_block

    LPAREN          shift and go to state 79


state 57

    (62) loop -> while .

    RBRACE          reduce using rule 62 (loop -> while .)


state 58

    (63) loop -> for .

    RBRACE          reduce using rule 63 (loop -> for .)


state 59

    (67) return -> RETURN . expr SEMI
    (68) return -> RETURN . SEMI
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    SEMI            shift and go to state 81
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 80
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 60

    (64) while -> WHILE . LPAREN expr RPAREN instruction_block

    LPAREN          shift and go to state 103


state 61

    (65) for -> FROM . LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM . LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    LPAREN          shift and go to state 104


state 62

    (18) single_function_definition_param -> type . ID

    ID              shift and go to state 105


state 63

    (8) single_function_definition -> FUNCTION type ID LPAREN function_definition_params . RPAREN local_variables_declaration instruction_block
    (9) single_function_definition -> FUNCTION type ID LPAREN function_definition_params . RPAREN instruction_block
    (16) function_definition_params -> function_definition_params . COMMA single_function_definition_param

    RPAREN          shift and go to state 106
    COMMA           shift and go to state 107


state 64

    (10) single_function_definition -> FUNCTION type ID LPAREN RPAREN . local_variables_declaration instruction_block
    (11) single_function_definition -> FUNCTION type ID LPAREN RPAREN . instruction_block
    (21) local_variables_declaration -> . LOCAL variables_declaration
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 32
    LBRACE          shift and go to state 33

    local_variables_declaration    shift and go to state 108
    instruction_block              shift and go to state 109

state 65

    (17) function_definition_params -> single_function_definition_param .

    RPAREN          reduce using rule 17 (function_definition_params -> single_function_definition_param .)
    COMMA           reduce using rule 17 (function_definition_params -> single_function_definition_param .)


state 66

    (12) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params . RPAREN local_variables_declaration instruction_block
    (13) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params . RPAREN instruction_block
    (16) function_definition_params -> function_definition_params . COMMA single_function_definition_param

    RPAREN          shift and go to state 110
    COMMA           shift and go to state 107


state 67

    (14) single_function_definition -> FUNCTION VOID ID LPAREN RPAREN . local_variables_declaration instruction_block
    (15) single_function_definition -> FUNCTION VOID ID LPAREN RPAREN . instruction_block
    (21) local_variables_declaration -> . LOCAL variables_declaration
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 32
    LBRACE          shift and go to state 33

    local_variables_declaration    shift and go to state 111
    instruction_block              shift and go to state 112

state 68

    (25) shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .

    INT             reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)
    REAL            reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)
    CHAR            reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)
    BOOL            reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)
    START           reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)
    FUNCTION        reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)
    LBRACE          reduce using rule 25 (shared_type_variables_declaration -> type shared_type_variables_declaration_list SEMI .)


state 69

    (26) shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA . single_variable_declaration
    (28) single_variable_declaration -> . ID dim_definition dim_definition
    (29) single_variable_declaration -> . ID dim_definition
    (30) single_variable_declaration -> . ID

    ID              shift and go to state 39

    single_variable_declaration    shift and go to state 113

state 70

    (28) single_variable_declaration -> ID dim_definition . dim_definition
    (29) single_variable_declaration -> ID dim_definition .
    (31) dim_definition -> . LBRACKET CONST_INT RBRACKET

    SEMI            reduce using rule 29 (single_variable_declaration -> ID dim_definition .)
    COMMA           reduce using rule 29 (single_variable_declaration -> ID dim_definition .)
    LBRACKET        shift and go to state 71

    dim_definition                 shift and go to state 114

state 71

    (31) dim_definition -> LBRACKET . CONST_INT RBRACKET

    CONST_INT       shift and go to state 115


state 72

    (32) instruction_block -> LBRACE statements RBRACE .

    $end            reduce using rule 32 (instruction_block -> LBRACE statements RBRACE .)
    START           reduce using rule 32 (instruction_block -> LBRACE statements RBRACE .)
    FUNCTION        reduce using rule 32 (instruction_block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 32 (instruction_block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 32 (instruction_block -> LBRACE statements RBRACE .)


state 73

    (42) assignment -> variable_access ASGMT . expr SEMI
    (43) assignment -> variable_access ASGMT . read
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (53) read -> . READ LPAREN RPAREN SEMI
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    READ            shift and go to state 54
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    variable_access                shift and go to state 93
    expr                           shift and go to state 116
    read                           shift and go to state 117
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 74

    (48) function_call -> ID LPAREN . function_call_params RPAREN SEMI
    (49) function_call -> ID LPAREN . RPAREN SEMI
    (50) function_call_params -> . function_call_params COMMA single_function_call_param
    (51) function_call_params -> . single_function_call_param
    (52) single_function_call_param -> . expr
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    RPAREN          shift and go to state 119
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    function_call_params           shift and go to state 118
    single_function_call_param     shift and go to state 120
    expr                           shift and go to state 121
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 75

    (44) variable_access -> ID dim_access . dim_access
    (45) variable_access -> ID dim_access .
    (47) dim_access -> . LBRACKET expr RBRACKET

    ASGMT           reduce using rule 45 (variable_access -> ID dim_access .)
    TIMES           reduce using rule 45 (variable_access -> ID dim_access .)
    DIVIDE          reduce using rule 45 (variable_access -> ID dim_access .)
    MODULO          reduce using rule 45 (variable_access -> ID dim_access .)
    PLUS            reduce using rule 45 (variable_access -> ID dim_access .)
    MINUS           reduce using rule 45 (variable_access -> ID dim_access .)
    LTHAN_EQUAL     reduce using rule 45 (variable_access -> ID dim_access .)
    LTHAN           reduce using rule 45 (variable_access -> ID dim_access .)
    GTHAN_EQUAL     reduce using rule 45 (variable_access -> ID dim_access .)
    GTHAN           reduce using rule 45 (variable_access -> ID dim_access .)
    EQUAL           reduce using rule 45 (variable_access -> ID dim_access .)
    NEQUAL          reduce using rule 45 (variable_access -> ID dim_access .)
    AND             reduce using rule 45 (variable_access -> ID dim_access .)
    SEMI            reduce using rule 45 (variable_access -> ID dim_access .)
    OR              reduce using rule 45 (variable_access -> ID dim_access .)
    RPAREN          reduce using rule 45 (variable_access -> ID dim_access .)
    COMMA           reduce using rule 45 (variable_access -> ID dim_access .)
    RBRACKET        reduce using rule 45 (variable_access -> ID dim_access .)
    LBRACKET        shift and go to state 76

    dim_access                     shift and go to state 122

state 76

    (47) dim_access -> LBRACKET . expr RBRACKET
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 123
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 77

    (53) read -> READ LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 124


state 78

    (54) print -> PRINT LPAREN . print_params RPAREN SEMI
    (55) print -> PRINT LPAREN . RPAREN SEMI
    (56) print_params -> . print_params COMMA single_print_param
    (57) print_params -> . single_print_param
    (58) single_print_param -> . expr
    (59) single_print_param -> . CONST_STRING
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    RPAREN          shift and go to state 126
    CONST_STRING    shift and go to state 129
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    print_params                   shift and go to state 125
    single_print_param             shift and go to state 127
    expr                           shift and go to state 128
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 79

    (60) conditional -> IF LPAREN . expr RPAREN instruction_block ELSE instruction_block
    (61) conditional -> IF LPAREN . expr RPAREN instruction_block
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 130
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 80

    (67) return -> RETURN expr . SEMI
    (69) expr -> expr . OR and_expr

    SEMI            shift and go to state 131
    OR              shift and go to state 132


state 81

    (68) return -> RETURN SEMI .

    RBRACE          reduce using rule 68 (return -> RETURN SEMI .)


state 82

    (70) expr -> and_expr .

    SEMI            reduce using rule 70 (expr -> and_expr .)
    OR              reduce using rule 70 (expr -> and_expr .)
    RPAREN          reduce using rule 70 (expr -> and_expr .)
    COMMA           reduce using rule 70 (expr -> and_expr .)
    RBRACKET        reduce using rule 70 (expr -> and_expr .)


state 83

    (71) and_expr -> equality_expr . AND equality_expr
    (72) and_expr -> equality_expr .

    AND             shift and go to state 133
    SEMI            reduce using rule 72 (and_expr -> equality_expr .)
    OR              reduce using rule 72 (and_expr -> equality_expr .)
    RPAREN          reduce using rule 72 (and_expr -> equality_expr .)
    COMMA           reduce using rule 72 (and_expr -> equality_expr .)
    RBRACKET        reduce using rule 72 (and_expr -> equality_expr .)


state 84

    (73) equality_expr -> relational_expr . EQUAL relational_expr
    (74) equality_expr -> relational_expr . NEQUAL relational_expr
    (75) equality_expr -> relational_expr .

    EQUAL           shift and go to state 134
    NEQUAL          shift and go to state 135
    AND             reduce using rule 75 (equality_expr -> relational_expr .)
    SEMI            reduce using rule 75 (equality_expr -> relational_expr .)
    OR              reduce using rule 75 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 75 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 75 (equality_expr -> relational_expr .)
    RBRACKET        reduce using rule 75 (equality_expr -> relational_expr .)


state 85

    (76) relational_expr -> additive_expr . LTHAN_EQUAL additive_expr
    (77) relational_expr -> additive_expr . LTHAN additive_expr
    (78) relational_expr -> additive_expr . GTHAN_EQUAL additive_expr
    (79) relational_expr -> additive_expr . GTHAN additive_expr
    (80) relational_expr -> additive_expr .

    LTHAN_EQUAL     shift and go to state 136
    LTHAN           shift and go to state 137
    GTHAN_EQUAL     shift and go to state 138
    GTHAN           shift and go to state 139
    EQUAL           reduce using rule 80 (relational_expr -> additive_expr .)
    NEQUAL          reduce using rule 80 (relational_expr -> additive_expr .)
    AND             reduce using rule 80 (relational_expr -> additive_expr .)
    SEMI            reduce using rule 80 (relational_expr -> additive_expr .)
    OR              reduce using rule 80 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 80 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 80 (relational_expr -> additive_expr .)
    RBRACKET        reduce using rule 80 (relational_expr -> additive_expr .)


state 86

    (81) additive_expr -> multiplicative_expr . PLUS multiplicative_expr
    (82) additive_expr -> multiplicative_expr . MINUS multiplicative_expr
    (83) additive_expr -> multiplicative_expr .

    PLUS            shift and go to state 140
    MINUS           shift and go to state 141
    LTHAN_EQUAL     reduce using rule 83 (additive_expr -> multiplicative_expr .)
    LTHAN           reduce using rule 83 (additive_expr -> multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 83 (additive_expr -> multiplicative_expr .)
    GTHAN           reduce using rule 83 (additive_expr -> multiplicative_expr .)
    EQUAL           reduce using rule 83 (additive_expr -> multiplicative_expr .)
    NEQUAL          reduce using rule 83 (additive_expr -> multiplicative_expr .)
    AND             reduce using rule 83 (additive_expr -> multiplicative_expr .)
    SEMI            reduce using rule 83 (additive_expr -> multiplicative_expr .)
    OR              reduce using rule 83 (additive_expr -> multiplicative_expr .)
    RPAREN          reduce using rule 83 (additive_expr -> multiplicative_expr .)
    COMMA           reduce using rule 83 (additive_expr -> multiplicative_expr .)
    RBRACKET        reduce using rule 83 (additive_expr -> multiplicative_expr .)


state 87

    (89) unary_expr -> PLUS . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    postfix_expr                   shift and go to state 142
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 88

    (88) unary_expr -> MINUS . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    postfix_expr                   shift and go to state 143
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 89

    (84) multiplicative_expr -> unary_expr . TIMES unary_expr
    (85) multiplicative_expr -> unary_expr . DIVIDE unary_expr
    (86) multiplicative_expr -> unary_expr . MODULO unary_expr
    (87) multiplicative_expr -> unary_expr .

    TIMES           shift and go to state 144
    DIVIDE          shift and go to state 145
    MODULO          shift and go to state 146
    PLUS            reduce using rule 87 (multiplicative_expr -> unary_expr .)
    MINUS           reduce using rule 87 (multiplicative_expr -> unary_expr .)
    LTHAN_EQUAL     reduce using rule 87 (multiplicative_expr -> unary_expr .)
    LTHAN           reduce using rule 87 (multiplicative_expr -> unary_expr .)
    GTHAN_EQUAL     reduce using rule 87 (multiplicative_expr -> unary_expr .)
    GTHAN           reduce using rule 87 (multiplicative_expr -> unary_expr .)
    EQUAL           reduce using rule 87 (multiplicative_expr -> unary_expr .)
    NEQUAL          reduce using rule 87 (multiplicative_expr -> unary_expr .)
    AND             reduce using rule 87 (multiplicative_expr -> unary_expr .)
    SEMI            reduce using rule 87 (multiplicative_expr -> unary_expr .)
    OR              reduce using rule 87 (multiplicative_expr -> unary_expr .)
    RPAREN          reduce using rule 87 (multiplicative_expr -> unary_expr .)
    COMMA           reduce using rule 87 (multiplicative_expr -> unary_expr .)
    RBRACKET        reduce using rule 87 (multiplicative_expr -> unary_expr .)


state 90

    (91) unary_expr -> postfix_expr .

    TIMES           reduce using rule 91 (unary_expr -> postfix_expr .)
    DIVIDE          reduce using rule 91 (unary_expr -> postfix_expr .)
    MODULO          reduce using rule 91 (unary_expr -> postfix_expr .)
    PLUS            reduce using rule 91 (unary_expr -> postfix_expr .)
    MINUS           reduce using rule 91 (unary_expr -> postfix_expr .)
    LTHAN_EQUAL     reduce using rule 91 (unary_expr -> postfix_expr .)
    LTHAN           reduce using rule 91 (unary_expr -> postfix_expr .)
    GTHAN_EQUAL     reduce using rule 91 (unary_expr -> postfix_expr .)
    GTHAN           reduce using rule 91 (unary_expr -> postfix_expr .)
    EQUAL           reduce using rule 91 (unary_expr -> postfix_expr .)
    NEQUAL          reduce using rule 91 (unary_expr -> postfix_expr .)
    AND             reduce using rule 91 (unary_expr -> postfix_expr .)
    SEMI            reduce using rule 91 (unary_expr -> postfix_expr .)
    OR              reduce using rule 91 (unary_expr -> postfix_expr .)
    RPAREN          reduce using rule 91 (unary_expr -> postfix_expr .)
    COMMA           reduce using rule 91 (unary_expr -> postfix_expr .)
    RBRACKET        reduce using rule 91 (unary_expr -> postfix_expr .)


state 91

    (90) unary_expr -> NOT . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    postfix_expr                   shift and go to state 147
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 92

    (92) postfix_expr -> LPAREN . expr RPAREN
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 148
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 93

    (93) postfix_expr -> variable_access .

    TIMES           reduce using rule 93 (postfix_expr -> variable_access .)
    DIVIDE          reduce using rule 93 (postfix_expr -> variable_access .)
    MODULO          reduce using rule 93 (postfix_expr -> variable_access .)
    PLUS            reduce using rule 93 (postfix_expr -> variable_access .)
    MINUS           reduce using rule 93 (postfix_expr -> variable_access .)
    LTHAN_EQUAL     reduce using rule 93 (postfix_expr -> variable_access .)
    LTHAN           reduce using rule 93 (postfix_expr -> variable_access .)
    GTHAN_EQUAL     reduce using rule 93 (postfix_expr -> variable_access .)
    GTHAN           reduce using rule 93 (postfix_expr -> variable_access .)
    EQUAL           reduce using rule 93 (postfix_expr -> variable_access .)
    NEQUAL          reduce using rule 93 (postfix_expr -> variable_access .)
    AND             reduce using rule 93 (postfix_expr -> variable_access .)
    SEMI            reduce using rule 93 (postfix_expr -> variable_access .)
    OR              reduce using rule 93 (postfix_expr -> variable_access .)
    RPAREN          reduce using rule 93 (postfix_expr -> variable_access .)
    COMMA           reduce using rule 93 (postfix_expr -> variable_access .)
    RBRACKET        reduce using rule 93 (postfix_expr -> variable_access .)


state 94

    (94) postfix_expr -> function_call .

    TIMES           reduce using rule 94 (postfix_expr -> function_call .)
    DIVIDE          reduce using rule 94 (postfix_expr -> function_call .)
    MODULO          reduce using rule 94 (postfix_expr -> function_call .)
    PLUS            reduce using rule 94 (postfix_expr -> function_call .)
    MINUS           reduce using rule 94 (postfix_expr -> function_call .)
    LTHAN_EQUAL     reduce using rule 94 (postfix_expr -> function_call .)
    LTHAN           reduce using rule 94 (postfix_expr -> function_call .)
    GTHAN_EQUAL     reduce using rule 94 (postfix_expr -> function_call .)
    GTHAN           reduce using rule 94 (postfix_expr -> function_call .)
    EQUAL           reduce using rule 94 (postfix_expr -> function_call .)
    NEQUAL          reduce using rule 94 (postfix_expr -> function_call .)
    AND             reduce using rule 94 (postfix_expr -> function_call .)
    SEMI            reduce using rule 94 (postfix_expr -> function_call .)
    OR              reduce using rule 94 (postfix_expr -> function_call .)
    RPAREN          reduce using rule 94 (postfix_expr -> function_call .)
    COMMA           reduce using rule 94 (postfix_expr -> function_call .)
    RBRACKET        reduce using rule 94 (postfix_expr -> function_call .)


state 95

    (95) postfix_expr -> constant .

    TIMES           reduce using rule 95 (postfix_expr -> constant .)
    DIVIDE          reduce using rule 95 (postfix_expr -> constant .)
    MODULO          reduce using rule 95 (postfix_expr -> constant .)
    PLUS            reduce using rule 95 (postfix_expr -> constant .)
    MINUS           reduce using rule 95 (postfix_expr -> constant .)
    LTHAN_EQUAL     reduce using rule 95 (postfix_expr -> constant .)
    LTHAN           reduce using rule 95 (postfix_expr -> constant .)
    GTHAN_EQUAL     reduce using rule 95 (postfix_expr -> constant .)
    GTHAN           reduce using rule 95 (postfix_expr -> constant .)
    EQUAL           reduce using rule 95 (postfix_expr -> constant .)
    NEQUAL          reduce using rule 95 (postfix_expr -> constant .)
    AND             reduce using rule 95 (postfix_expr -> constant .)
    SEMI            reduce using rule 95 (postfix_expr -> constant .)
    OR              reduce using rule 95 (postfix_expr -> constant .)
    RPAREN          reduce using rule 95 (postfix_expr -> constant .)
    COMMA           reduce using rule 95 (postfix_expr -> constant .)
    RBRACKET        reduce using rule 95 (postfix_expr -> constant .)


state 96

    (44) variable_access -> ID . dim_access dim_access
    (45) variable_access -> ID . dim_access
    (46) variable_access -> ID .
    (48) function_call -> ID . LPAREN function_call_params RPAREN SEMI
    (49) function_call -> ID . LPAREN RPAREN SEMI
    (47) dim_access -> . LBRACKET expr RBRACKET

    TIMES           reduce using rule 46 (variable_access -> ID .)
    DIVIDE          reduce using rule 46 (variable_access -> ID .)
    MODULO          reduce using rule 46 (variable_access -> ID .)
    PLUS            reduce using rule 46 (variable_access -> ID .)
    MINUS           reduce using rule 46 (variable_access -> ID .)
    LTHAN_EQUAL     reduce using rule 46 (variable_access -> ID .)
    LTHAN           reduce using rule 46 (variable_access -> ID .)
    GTHAN_EQUAL     reduce using rule 46 (variable_access -> ID .)
    GTHAN           reduce using rule 46 (variable_access -> ID .)
    EQUAL           reduce using rule 46 (variable_access -> ID .)
    NEQUAL          reduce using rule 46 (variable_access -> ID .)
    AND             reduce using rule 46 (variable_access -> ID .)
    SEMI            reduce using rule 46 (variable_access -> ID .)
    OR              reduce using rule 46 (variable_access -> ID .)
    RPAREN          reduce using rule 46 (variable_access -> ID .)
    COMMA           reduce using rule 46 (variable_access -> ID .)
    RBRACKET        reduce using rule 46 (variable_access -> ID .)
    LPAREN          shift and go to state 74
    LBRACKET        shift and go to state 76

    dim_access                     shift and go to state 75

state 97

    (96) constant -> CONST_INT .

    TIMES           reduce using rule 96 (constant -> CONST_INT .)
    DIVIDE          reduce using rule 96 (constant -> CONST_INT .)
    MODULO          reduce using rule 96 (constant -> CONST_INT .)
    PLUS            reduce using rule 96 (constant -> CONST_INT .)
    MINUS           reduce using rule 96 (constant -> CONST_INT .)
    LTHAN_EQUAL     reduce using rule 96 (constant -> CONST_INT .)
    LTHAN           reduce using rule 96 (constant -> CONST_INT .)
    GTHAN_EQUAL     reduce using rule 96 (constant -> CONST_INT .)
    GTHAN           reduce using rule 96 (constant -> CONST_INT .)
    EQUAL           reduce using rule 96 (constant -> CONST_INT .)
    NEQUAL          reduce using rule 96 (constant -> CONST_INT .)
    AND             reduce using rule 96 (constant -> CONST_INT .)
    SEMI            reduce using rule 96 (constant -> CONST_INT .)
    OR              reduce using rule 96 (constant -> CONST_INT .)
    RPAREN          reduce using rule 96 (constant -> CONST_INT .)
    COMMA           reduce using rule 96 (constant -> CONST_INT .)
    RBRACKET        reduce using rule 96 (constant -> CONST_INT .)


state 98

    (97) constant -> CONST_REAL .

    TIMES           reduce using rule 97 (constant -> CONST_REAL .)
    DIVIDE          reduce using rule 97 (constant -> CONST_REAL .)
    MODULO          reduce using rule 97 (constant -> CONST_REAL .)
    PLUS            reduce using rule 97 (constant -> CONST_REAL .)
    MINUS           reduce using rule 97 (constant -> CONST_REAL .)
    LTHAN_EQUAL     reduce using rule 97 (constant -> CONST_REAL .)
    LTHAN           reduce using rule 97 (constant -> CONST_REAL .)
    GTHAN_EQUAL     reduce using rule 97 (constant -> CONST_REAL .)
    GTHAN           reduce using rule 97 (constant -> CONST_REAL .)
    EQUAL           reduce using rule 97 (constant -> CONST_REAL .)
    NEQUAL          reduce using rule 97 (constant -> CONST_REAL .)
    AND             reduce using rule 97 (constant -> CONST_REAL .)
    SEMI            reduce using rule 97 (constant -> CONST_REAL .)
    OR              reduce using rule 97 (constant -> CONST_REAL .)
    RPAREN          reduce using rule 97 (constant -> CONST_REAL .)
    COMMA           reduce using rule 97 (constant -> CONST_REAL .)
    RBRACKET        reduce using rule 97 (constant -> CONST_REAL .)


state 99

    (98) constant -> CONST_CHAR .

    TIMES           reduce using rule 98 (constant -> CONST_CHAR .)
    DIVIDE          reduce using rule 98 (constant -> CONST_CHAR .)
    MODULO          reduce using rule 98 (constant -> CONST_CHAR .)
    PLUS            reduce using rule 98 (constant -> CONST_CHAR .)
    MINUS           reduce using rule 98 (constant -> CONST_CHAR .)
    LTHAN_EQUAL     reduce using rule 98 (constant -> CONST_CHAR .)
    LTHAN           reduce using rule 98 (constant -> CONST_CHAR .)
    GTHAN_EQUAL     reduce using rule 98 (constant -> CONST_CHAR .)
    GTHAN           reduce using rule 98 (constant -> CONST_CHAR .)
    EQUAL           reduce using rule 98 (constant -> CONST_CHAR .)
    NEQUAL          reduce using rule 98 (constant -> CONST_CHAR .)
    AND             reduce using rule 98 (constant -> CONST_CHAR .)
    SEMI            reduce using rule 98 (constant -> CONST_CHAR .)
    OR              reduce using rule 98 (constant -> CONST_CHAR .)
    RPAREN          reduce using rule 98 (constant -> CONST_CHAR .)
    COMMA           reduce using rule 98 (constant -> CONST_CHAR .)
    RBRACKET        reduce using rule 98 (constant -> CONST_CHAR .)


state 100

    (99) constant -> constant_bool .

    TIMES           reduce using rule 99 (constant -> constant_bool .)
    DIVIDE          reduce using rule 99 (constant -> constant_bool .)
    MODULO          reduce using rule 99 (constant -> constant_bool .)
    PLUS            reduce using rule 99 (constant -> constant_bool .)
    MINUS           reduce using rule 99 (constant -> constant_bool .)
    LTHAN_EQUAL     reduce using rule 99 (constant -> constant_bool .)
    LTHAN           reduce using rule 99 (constant -> constant_bool .)
    GTHAN_EQUAL     reduce using rule 99 (constant -> constant_bool .)
    GTHAN           reduce using rule 99 (constant -> constant_bool .)
    EQUAL           reduce using rule 99 (constant -> constant_bool .)
    NEQUAL          reduce using rule 99 (constant -> constant_bool .)
    AND             reduce using rule 99 (constant -> constant_bool .)
    SEMI            reduce using rule 99 (constant -> constant_bool .)
    OR              reduce using rule 99 (constant -> constant_bool .)
    RPAREN          reduce using rule 99 (constant -> constant_bool .)
    COMMA           reduce using rule 99 (constant -> constant_bool .)
    RBRACKET        reduce using rule 99 (constant -> constant_bool .)


state 101

    (100) constant_bool -> TRUE .

    TIMES           reduce using rule 100 (constant_bool -> TRUE .)
    DIVIDE          reduce using rule 100 (constant_bool -> TRUE .)
    MODULO          reduce using rule 100 (constant_bool -> TRUE .)
    PLUS            reduce using rule 100 (constant_bool -> TRUE .)
    MINUS           reduce using rule 100 (constant_bool -> TRUE .)
    LTHAN_EQUAL     reduce using rule 100 (constant_bool -> TRUE .)
    LTHAN           reduce using rule 100 (constant_bool -> TRUE .)
    GTHAN_EQUAL     reduce using rule 100 (constant_bool -> TRUE .)
    GTHAN           reduce using rule 100 (constant_bool -> TRUE .)
    EQUAL           reduce using rule 100 (constant_bool -> TRUE .)
    NEQUAL          reduce using rule 100 (constant_bool -> TRUE .)
    AND             reduce using rule 100 (constant_bool -> TRUE .)
    SEMI            reduce using rule 100 (constant_bool -> TRUE .)
    OR              reduce using rule 100 (constant_bool -> TRUE .)
    RPAREN          reduce using rule 100 (constant_bool -> TRUE .)
    COMMA           reduce using rule 100 (constant_bool -> TRUE .)
    RBRACKET        reduce using rule 100 (constant_bool -> TRUE .)


state 102

    (101) constant_bool -> FALSE .

    TIMES           reduce using rule 101 (constant_bool -> FALSE .)
    DIVIDE          reduce using rule 101 (constant_bool -> FALSE .)
    MODULO          reduce using rule 101 (constant_bool -> FALSE .)
    PLUS            reduce using rule 101 (constant_bool -> FALSE .)
    MINUS           reduce using rule 101 (constant_bool -> FALSE .)
    LTHAN_EQUAL     reduce using rule 101 (constant_bool -> FALSE .)
    LTHAN           reduce using rule 101 (constant_bool -> FALSE .)
    GTHAN_EQUAL     reduce using rule 101 (constant_bool -> FALSE .)
    GTHAN           reduce using rule 101 (constant_bool -> FALSE .)
    EQUAL           reduce using rule 101 (constant_bool -> FALSE .)
    NEQUAL          reduce using rule 101 (constant_bool -> FALSE .)
    AND             reduce using rule 101 (constant_bool -> FALSE .)
    SEMI            reduce using rule 101 (constant_bool -> FALSE .)
    OR              reduce using rule 101 (constant_bool -> FALSE .)
    RPAREN          reduce using rule 101 (constant_bool -> FALSE .)
    COMMA           reduce using rule 101 (constant_bool -> FALSE .)
    RBRACKET        reduce using rule 101 (constant_bool -> FALSE .)


state 103

    (64) while -> WHILE LPAREN . expr RPAREN instruction_block
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    expr                           shift and go to state 149
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 104

    (65) for -> FROM LPAREN . ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM LPAREN . ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    ID              shift and go to state 150


state 105

    (18) single_function_definition_param -> type ID .

    RPAREN          reduce using rule 18 (single_function_definition_param -> type ID .)
    COMMA           reduce using rule 18 (single_function_definition_param -> type ID .)


state 106

    (8) single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN . local_variables_declaration instruction_block
    (9) single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN . instruction_block
    (21) local_variables_declaration -> . LOCAL variables_declaration
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 32
    LBRACE          shift and go to state 33

    local_variables_declaration    shift and go to state 151
    instruction_block              shift and go to state 152

state 107

    (16) function_definition_params -> function_definition_params COMMA . single_function_definition_param
    (18) single_function_definition_param -> . type ID
    (102) type -> . INT
    (103) type -> . REAL
    (104) type -> . CHAR
    (105) type -> . BOOL

    INT             shift and go to state 18
    REAL            shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21

    single_function_definition_param shift and go to state 153
    type                           shift and go to state 62

state 108

    (10) single_function_definition -> FUNCTION type ID LPAREN RPAREN local_variables_declaration . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 154

state 109

    (11) single_function_definition -> FUNCTION type ID LPAREN RPAREN instruction_block .

    START           reduce using rule 11 (single_function_definition -> FUNCTION type ID LPAREN RPAREN instruction_block .)
    FUNCTION        reduce using rule 11 (single_function_definition -> FUNCTION type ID LPAREN RPAREN instruction_block .)


state 110

    (12) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN . local_variables_declaration instruction_block
    (13) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN . instruction_block
    (21) local_variables_declaration -> . LOCAL variables_declaration
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 32
    LBRACE          shift and go to state 33

    local_variables_declaration    shift and go to state 155
    instruction_block              shift and go to state 156

state 111

    (14) single_function_definition -> FUNCTION VOID ID LPAREN RPAREN local_variables_declaration . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 157

state 112

    (15) single_function_definition -> FUNCTION VOID ID LPAREN RPAREN instruction_block .

    START           reduce using rule 15 (single_function_definition -> FUNCTION VOID ID LPAREN RPAREN instruction_block .)
    FUNCTION        reduce using rule 15 (single_function_definition -> FUNCTION VOID ID LPAREN RPAREN instruction_block .)


state 113

    (26) shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .

    SEMI            reduce using rule 26 (shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .)
    COMMA           reduce using rule 26 (shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .)


state 114

    (28) single_variable_declaration -> ID dim_definition dim_definition .

    SEMI            reduce using rule 28 (single_variable_declaration -> ID dim_definition dim_definition .)
    COMMA           reduce using rule 28 (single_variable_declaration -> ID dim_definition dim_definition .)


state 115

    (31) dim_definition -> LBRACKET CONST_INT . RBRACKET

    RBRACKET        shift and go to state 158


state 116

    (42) assignment -> variable_access ASGMT expr . SEMI
    (69) expr -> expr . OR and_expr

    SEMI            shift and go to state 159
    OR              shift and go to state 132


state 117

    (43) assignment -> variable_access ASGMT read .

    RBRACE          reduce using rule 43 (assignment -> variable_access ASGMT read .)


state 118

    (48) function_call -> ID LPAREN function_call_params . RPAREN SEMI
    (50) function_call_params -> function_call_params . COMMA single_function_call_param

    RPAREN          shift and go to state 160
    COMMA           shift and go to state 161


state 119

    (49) function_call -> ID LPAREN RPAREN . SEMI

    SEMI            shift and go to state 162


state 120

    (51) function_call_params -> single_function_call_param .

    RPAREN          reduce using rule 51 (function_call_params -> single_function_call_param .)
    COMMA           reduce using rule 51 (function_call_params -> single_function_call_param .)


state 121

    (52) single_function_call_param -> expr .
    (69) expr -> expr . OR and_expr

    RPAREN          reduce using rule 52 (single_function_call_param -> expr .)
    COMMA           reduce using rule 52 (single_function_call_param -> expr .)
    OR              shift and go to state 132


state 122

    (44) variable_access -> ID dim_access dim_access .

    ASGMT           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    TIMES           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    DIVIDE          reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    MODULO          reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    PLUS            reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    MINUS           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    LTHAN_EQUAL     reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    LTHAN           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    GTHAN_EQUAL     reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    GTHAN           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    EQUAL           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    NEQUAL          reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    AND             reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    SEMI            reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    OR              reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    RPAREN          reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    COMMA           reduce using rule 44 (variable_access -> ID dim_access dim_access .)
    RBRACKET        reduce using rule 44 (variable_access -> ID dim_access dim_access .)


state 123

    (47) dim_access -> LBRACKET expr . RBRACKET
    (69) expr -> expr . OR and_expr

    RBRACKET        shift and go to state 163
    OR              shift and go to state 132


state 124

    (53) read -> READ LPAREN RPAREN . SEMI

    SEMI            shift and go to state 164


state 125

    (54) print -> PRINT LPAREN print_params . RPAREN SEMI
    (56) print_params -> print_params . COMMA single_print_param

    RPAREN          shift and go to state 165
    COMMA           shift and go to state 166


state 126

    (55) print -> PRINT LPAREN RPAREN . SEMI

    SEMI            shift and go to state 167


state 127

    (57) print_params -> single_print_param .

    RPAREN          reduce using rule 57 (print_params -> single_print_param .)
    COMMA           reduce using rule 57 (print_params -> single_print_param .)


state 128

    (58) single_print_param -> expr .
    (69) expr -> expr . OR and_expr

    RPAREN          reduce using rule 58 (single_print_param -> expr .)
    COMMA           reduce using rule 58 (single_print_param -> expr .)
    OR              shift and go to state 132


state 129

    (59) single_print_param -> CONST_STRING .

    RPAREN          reduce using rule 59 (single_print_param -> CONST_STRING .)
    COMMA           reduce using rule 59 (single_print_param -> CONST_STRING .)


state 130

    (60) conditional -> IF LPAREN expr . RPAREN instruction_block ELSE instruction_block
    (61) conditional -> IF LPAREN expr . RPAREN instruction_block
    (69) expr -> expr . OR and_expr

    RPAREN          shift and go to state 168
    OR              shift and go to state 132


state 131

    (67) return -> RETURN expr SEMI .

    RBRACE          reduce using rule 67 (return -> RETURN expr SEMI .)


state 132

    (69) expr -> expr OR . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    and_expr                       shift and go to state 169
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 133

    (71) and_expr -> equality_expr AND . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    equality_expr                  shift and go to state 170
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 134

    (73) equality_expr -> relational_expr EQUAL . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    relational_expr                shift and go to state 171
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 135

    (74) equality_expr -> relational_expr NEQUAL . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    relational_expr                shift and go to state 172
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 136

    (76) relational_expr -> additive_expr LTHAN_EQUAL . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 173
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 137

    (77) relational_expr -> additive_expr LTHAN . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 174
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 138

    (78) relational_expr -> additive_expr GTHAN_EQUAL . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 175
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 139

    (79) relational_expr -> additive_expr GTHAN . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    additive_expr                  shift and go to state 176
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 140

    (81) additive_expr -> multiplicative_expr PLUS . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    multiplicative_expr            shift and go to state 177
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 141

    (82) additive_expr -> multiplicative_expr MINUS . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    multiplicative_expr            shift and go to state 178
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 142

    (89) unary_expr -> PLUS postfix_expr .

    TIMES           reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    DIVIDE          reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    MODULO          reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    PLUS            reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    MINUS           reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    LTHAN_EQUAL     reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    LTHAN           reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    GTHAN_EQUAL     reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    GTHAN           reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    EQUAL           reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    NEQUAL          reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    AND             reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    SEMI            reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    OR              reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    RPAREN          reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    COMMA           reduce using rule 89 (unary_expr -> PLUS postfix_expr .)
    RBRACKET        reduce using rule 89 (unary_expr -> PLUS postfix_expr .)


state 143

    (88) unary_expr -> MINUS postfix_expr .

    TIMES           reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    DIVIDE          reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    MODULO          reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    PLUS            reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    MINUS           reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    LTHAN_EQUAL     reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    LTHAN           reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    GTHAN_EQUAL     reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    GTHAN           reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    EQUAL           reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    NEQUAL          reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    AND             reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    SEMI            reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    OR              reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    RPAREN          reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    COMMA           reduce using rule 88 (unary_expr -> MINUS postfix_expr .)
    RBRACKET        reduce using rule 88 (unary_expr -> MINUS postfix_expr .)


state 144

    (84) multiplicative_expr -> unary_expr TIMES . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    unary_expr                     shift and go to state 179
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 145

    (85) multiplicative_expr -> unary_expr DIVIDE . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    unary_expr                     shift and go to state 180
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 146

    (86) multiplicative_expr -> unary_expr MODULO . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    unary_expr                     shift and go to state 181
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 147

    (90) unary_expr -> NOT postfix_expr .

    TIMES           reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    DIVIDE          reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    MODULO          reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    PLUS            reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    MINUS           reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    LTHAN_EQUAL     reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    LTHAN           reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    GTHAN_EQUAL     reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    GTHAN           reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    EQUAL           reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    NEQUAL          reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    AND             reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    SEMI            reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    OR              reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    RPAREN          reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    COMMA           reduce using rule 90 (unary_expr -> NOT postfix_expr .)
    RBRACKET        reduce using rule 90 (unary_expr -> NOT postfix_expr .)


state 148

    (92) postfix_expr -> LPAREN expr . RPAREN
    (69) expr -> expr . OR and_expr

    RPAREN          shift and go to state 182
    OR              shift and go to state 132


state 149

    (64) while -> WHILE LPAREN expr . RPAREN instruction_block
    (69) expr -> expr . OR and_expr

    RPAREN          shift and go to state 183
    OR              shift and go to state 132


state 150

    (65) for -> FROM LPAREN ID . ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM LPAREN ID . ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block

    ASGMT           shift and go to state 184


state 151

    (8) single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 185

state 152

    (9) single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block .

    START           reduce using rule 9 (single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block .)
    FUNCTION        reduce using rule 9 (single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN instruction_block .)


state 153

    (16) function_definition_params -> function_definition_params COMMA single_function_definition_param .

    RPAREN          reduce using rule 16 (function_definition_params -> function_definition_params COMMA single_function_definition_param .)
    COMMA           reduce using rule 16 (function_definition_params -> function_definition_params COMMA single_function_definition_param .)


state 154

    (10) single_function_definition -> FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 10 (single_function_definition -> FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 10 (single_function_definition -> FUNCTION type ID LPAREN RPAREN local_variables_declaration instruction_block .)


state 155

    (12) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 186

state 156

    (13) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block .

    START           reduce using rule 13 (single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block .)
    FUNCTION        reduce using rule 13 (single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN instruction_block .)


state 157

    (14) single_function_definition -> FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 14 (single_function_definition -> FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 14 (single_function_definition -> FUNCTION VOID ID LPAREN RPAREN local_variables_declaration instruction_block .)


state 158

    (31) dim_definition -> LBRACKET CONST_INT RBRACKET .

    LBRACKET        reduce using rule 31 (dim_definition -> LBRACKET CONST_INT RBRACKET .)
    SEMI            reduce using rule 31 (dim_definition -> LBRACKET CONST_INT RBRACKET .)
    COMMA           reduce using rule 31 (dim_definition -> LBRACKET CONST_INT RBRACKET .)


state 159

    (42) assignment -> variable_access ASGMT expr SEMI .

    RBRACE          reduce using rule 42 (assignment -> variable_access ASGMT expr SEMI .)


state 160

    (48) function_call -> ID LPAREN function_call_params RPAREN . SEMI

    SEMI            shift and go to state 187


state 161

    (50) function_call_params -> function_call_params COMMA . single_function_call_param
    (52) single_function_call_param -> . expr
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    single_function_call_param     shift and go to state 188
    expr                           shift and go to state 121
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 162

    (49) function_call -> ID LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    TIMES           reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    DIVIDE          reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    MODULO          reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    PLUS            reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    MINUS           reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    LTHAN_EQUAL     reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    LTHAN           reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    GTHAN_EQUAL     reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    GTHAN           reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    EQUAL           reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    NEQUAL          reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    AND             reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    SEMI            reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    OR              reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    RPAREN          reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    COMMA           reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)
    RBRACKET        reduce using rule 49 (function_call -> ID LPAREN RPAREN SEMI .)


state 163

    (47) dim_access -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    ASGMT           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    LTHAN_EQUAL     reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    LTHAN           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    GTHAN_EQUAL     reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    GTHAN           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    NEQUAL          reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 47 (dim_access -> LBRACKET expr RBRACKET .)


state 164

    (53) read -> READ LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 53 (read -> READ LPAREN RPAREN SEMI .)


state 165

    (54) print -> PRINT LPAREN print_params RPAREN . SEMI

    SEMI            shift and go to state 189


state 166

    (56) print_params -> print_params COMMA . single_print_param
    (58) single_print_param -> . expr
    (59) single_print_param -> . CONST_STRING
    (69) expr -> . expr OR and_expr
    (70) expr -> . and_expr
    (71) and_expr -> . equality_expr AND equality_expr
    (72) and_expr -> . equality_expr
    (73) equality_expr -> . relational_expr EQUAL relational_expr
    (74) equality_expr -> . relational_expr NEQUAL relational_expr
    (75) equality_expr -> . relational_expr
    (76) relational_expr -> . additive_expr LTHAN_EQUAL additive_expr
    (77) relational_expr -> . additive_expr LTHAN additive_expr
    (78) relational_expr -> . additive_expr GTHAN_EQUAL additive_expr
    (79) relational_expr -> . additive_expr GTHAN additive_expr
    (80) relational_expr -> . additive_expr
    (81) additive_expr -> . multiplicative_expr PLUS multiplicative_expr
    (82) additive_expr -> . multiplicative_expr MINUS multiplicative_expr
    (83) additive_expr -> . multiplicative_expr
    (84) multiplicative_expr -> . unary_expr TIMES unary_expr
    (85) multiplicative_expr -> . unary_expr DIVIDE unary_expr
    (86) multiplicative_expr -> . unary_expr MODULO unary_expr
    (87) multiplicative_expr -> . unary_expr
    (88) unary_expr -> . MINUS postfix_expr
    (89) unary_expr -> . PLUS postfix_expr
    (90) unary_expr -> . NOT postfix_expr
    (91) unary_expr -> . postfix_expr
    (92) postfix_expr -> . LPAREN expr RPAREN
    (93) postfix_expr -> . variable_access
    (94) postfix_expr -> . function_call
    (95) postfix_expr -> . constant
    (44) variable_access -> . ID dim_access dim_access
    (45) variable_access -> . ID dim_access
    (46) variable_access -> . ID
    (48) function_call -> . ID LPAREN function_call_params RPAREN SEMI
    (49) function_call -> . ID LPAREN RPAREN SEMI
    (96) constant -> . CONST_INT
    (97) constant -> . CONST_REAL
    (98) constant -> . CONST_CHAR
    (99) constant -> . constant_bool
    (100) constant_bool -> . TRUE
    (101) constant_bool -> . FALSE

    CONST_STRING    shift and go to state 129
    MINUS           shift and go to state 88
    PLUS            shift and go to state 87
    NOT             shift and go to state 91
    LPAREN          shift and go to state 92
    ID              shift and go to state 96
    CONST_INT       shift and go to state 97
    CONST_REAL      shift and go to state 98
    CONST_CHAR      shift and go to state 99
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    single_print_param             shift and go to state 190
    expr                           shift and go to state 128
    and_expr                       shift and go to state 82
    equality_expr                  shift and go to state 83
    relational_expr                shift and go to state 84
    additive_expr                  shift and go to state 85
    multiplicative_expr            shift and go to state 86
    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 90
    variable_access                shift and go to state 93
    function_call                  shift and go to state 94
    constant                       shift and go to state 95
    constant_bool                  shift and go to state 100

state 167

    (55) print -> PRINT LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 55 (print -> PRINT LPAREN RPAREN SEMI .)


state 168

    (60) conditional -> IF LPAREN expr RPAREN . instruction_block ELSE instruction_block
    (61) conditional -> IF LPAREN expr RPAREN . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 191

state 169

    (69) expr -> expr OR and_expr .

    SEMI            reduce using rule 69 (expr -> expr OR and_expr .)
    OR              reduce using rule 69 (expr -> expr OR and_expr .)
    RPAREN          reduce using rule 69 (expr -> expr OR and_expr .)
    COMMA           reduce using rule 69 (expr -> expr OR and_expr .)
    RBRACKET        reduce using rule 69 (expr -> expr OR and_expr .)


state 170

    (71) and_expr -> equality_expr AND equality_expr .

    SEMI            reduce using rule 71 (and_expr -> equality_expr AND equality_expr .)
    OR              reduce using rule 71 (and_expr -> equality_expr AND equality_expr .)
    RPAREN          reduce using rule 71 (and_expr -> equality_expr AND equality_expr .)
    COMMA           reduce using rule 71 (and_expr -> equality_expr AND equality_expr .)
    RBRACKET        reduce using rule 71 (and_expr -> equality_expr AND equality_expr .)


state 171

    (73) equality_expr -> relational_expr EQUAL relational_expr .

    AND             reduce using rule 73 (equality_expr -> relational_expr EQUAL relational_expr .)
    SEMI            reduce using rule 73 (equality_expr -> relational_expr EQUAL relational_expr .)
    OR              reduce using rule 73 (equality_expr -> relational_expr EQUAL relational_expr .)
    RPAREN          reduce using rule 73 (equality_expr -> relational_expr EQUAL relational_expr .)
    COMMA           reduce using rule 73 (equality_expr -> relational_expr EQUAL relational_expr .)
    RBRACKET        reduce using rule 73 (equality_expr -> relational_expr EQUAL relational_expr .)


state 172

    (74) equality_expr -> relational_expr NEQUAL relational_expr .

    AND             reduce using rule 74 (equality_expr -> relational_expr NEQUAL relational_expr .)
    SEMI            reduce using rule 74 (equality_expr -> relational_expr NEQUAL relational_expr .)
    OR              reduce using rule 74 (equality_expr -> relational_expr NEQUAL relational_expr .)
    RPAREN          reduce using rule 74 (equality_expr -> relational_expr NEQUAL relational_expr .)
    COMMA           reduce using rule 74 (equality_expr -> relational_expr NEQUAL relational_expr .)
    RBRACKET        reduce using rule 74 (equality_expr -> relational_expr NEQUAL relational_expr .)


state 173

    (76) relational_expr -> additive_expr LTHAN_EQUAL additive_expr .

    EQUAL           reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    NEQUAL          reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    AND             reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    SEMI            reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    OR              reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    RPAREN          reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    COMMA           reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)
    RBRACKET        reduce using rule 76 (relational_expr -> additive_expr LTHAN_EQUAL additive_expr .)


state 174

    (77) relational_expr -> additive_expr LTHAN additive_expr .

    EQUAL           reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    NEQUAL          reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    AND             reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    SEMI            reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    OR              reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    RPAREN          reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    COMMA           reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)
    RBRACKET        reduce using rule 77 (relational_expr -> additive_expr LTHAN additive_expr .)


state 175

    (78) relational_expr -> additive_expr GTHAN_EQUAL additive_expr .

    EQUAL           reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    NEQUAL          reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    AND             reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    SEMI            reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    OR              reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    RPAREN          reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    COMMA           reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)
    RBRACKET        reduce using rule 78 (relational_expr -> additive_expr GTHAN_EQUAL additive_expr .)


state 176

    (79) relational_expr -> additive_expr GTHAN additive_expr .

    EQUAL           reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    NEQUAL          reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    AND             reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    SEMI            reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    OR              reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    RPAREN          reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    COMMA           reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)
    RBRACKET        reduce using rule 79 (relational_expr -> additive_expr GTHAN additive_expr .)


state 177

    (81) additive_expr -> multiplicative_expr PLUS multiplicative_expr .

    LTHAN_EQUAL     reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    LTHAN           reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    GTHAN           reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    EQUAL           reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    NEQUAL          reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    AND             reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    SEMI            reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    OR              reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    RPAREN          reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    COMMA           reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)
    RBRACKET        reduce using rule 81 (additive_expr -> multiplicative_expr PLUS multiplicative_expr .)


state 178

    (82) additive_expr -> multiplicative_expr MINUS multiplicative_expr .

    LTHAN_EQUAL     reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    LTHAN           reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    GTHAN           reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    EQUAL           reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    NEQUAL          reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    AND             reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    SEMI            reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    OR              reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    RPAREN          reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    COMMA           reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)
    RBRACKET        reduce using rule 82 (additive_expr -> multiplicative_expr MINUS multiplicative_expr .)


state 179

    (84) multiplicative_expr -> unary_expr TIMES unary_expr .

    PLUS            reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    MINUS           reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    LTHAN_EQUAL     reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    LTHAN           reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    GTHAN_EQUAL     reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    GTHAN           reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    EQUAL           reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    NEQUAL          reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    AND             reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    SEMI            reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    OR              reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    RPAREN          reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    COMMA           reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)
    RBRACKET        reduce using rule 84 (multiplicative_expr -> unary_expr TIMES unary_expr .)


state 180

    (85) multiplicative_expr -> unary_expr DIVIDE unary_expr .

    PLUS            reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    MINUS           reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    LTHAN_EQUAL     reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    LTHAN           reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    GTHAN_EQUAL     reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    GTHAN           reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    EQUAL           reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    NEQUAL          reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    AND             reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    SEMI            reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    OR              reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    RPAREN          reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    COMMA           reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)
    RBRACKET        reduce using rule 85 (multiplicative_expr -> unary_expr DIVIDE unary_expr .)


state 181

    (86) multiplicative_expr -> unary_expr MODULO unary_expr .

    PLUS            reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    MINUS           reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    LTHAN_EQUAL     reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    LTHAN           reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    GTHAN_EQUAL     reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    GTHAN           reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    EQUAL           reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    NEQUAL          reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    AND             reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    SEMI            reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    OR              reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    RPAREN          reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    COMMA           reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)
    RBRACKET        reduce using rule 86 (multiplicative_expr -> unary_expr MODULO unary_expr .)


state 182

    (92) postfix_expr -> LPAREN expr RPAREN .

    TIMES           reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    MODULO          reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    LTHAN_EQUAL     reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    LTHAN           reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    GTHAN_EQUAL     reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    GTHAN           reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    NEQUAL          reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 92 (postfix_expr -> LPAREN expr RPAREN .)


state 183

    (64) while -> WHILE LPAREN expr RPAREN . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 192

state 184

    (65) for -> FROM LPAREN ID ASGMT . CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM LPAREN ID ASGMT . CONST_INT COLON CONST_INT RPAREN instruction_block

    CONST_INT       shift and go to state 193


state 185

    (8) single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 8 (single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 8 (single_function_definition -> FUNCTION type ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)


state 186

    (12) single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 12 (single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 12 (single_function_definition -> FUNCTION VOID ID LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)


state 187

    (48) function_call -> ID LPAREN function_call_params RPAREN SEMI .

    RBRACE          reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    TIMES           reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    DIVIDE          reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    MODULO          reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    PLUS            reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    MINUS           reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    LTHAN_EQUAL     reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    LTHAN           reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    GTHAN_EQUAL     reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    GTHAN           reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    EQUAL           reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    NEQUAL          reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    AND             reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    SEMI            reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    OR              reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    RPAREN          reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    COMMA           reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)
    RBRACKET        reduce using rule 48 (function_call -> ID LPAREN function_call_params RPAREN SEMI .)


state 188

    (50) function_call_params -> function_call_params COMMA single_function_call_param .

    RPAREN          reduce using rule 50 (function_call_params -> function_call_params COMMA single_function_call_param .)
    COMMA           reduce using rule 50 (function_call_params -> function_call_params COMMA single_function_call_param .)


state 189

    (54) print -> PRINT LPAREN print_params RPAREN SEMI .

    RBRACE          reduce using rule 54 (print -> PRINT LPAREN print_params RPAREN SEMI .)


state 190

    (56) print_params -> print_params COMMA single_print_param .

    RPAREN          reduce using rule 56 (print_params -> print_params COMMA single_print_param .)
    COMMA           reduce using rule 56 (print_params -> print_params COMMA single_print_param .)


state 191

    (60) conditional -> IF LPAREN expr RPAREN instruction_block . ELSE instruction_block
    (61) conditional -> IF LPAREN expr RPAREN instruction_block .

    ELSE            shift and go to state 194
    RBRACE          reduce using rule 61 (conditional -> IF LPAREN expr RPAREN instruction_block .)


state 192

    (64) while -> WHILE LPAREN expr RPAREN instruction_block .

    RBRACE          reduce using rule 64 (while -> WHILE LPAREN expr RPAREN instruction_block .)


state 193

    (65) for -> FROM LPAREN ID ASGMT CONST_INT . COLON CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM LPAREN ID ASGMT CONST_INT . COLON CONST_INT RPAREN instruction_block

    COLON           shift and go to state 195


state 194

    (60) conditional -> IF LPAREN expr RPAREN instruction_block ELSE . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 196

state 195

    (65) for -> FROM LPAREN ID ASGMT CONST_INT COLON . CONST_INT COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM LPAREN ID ASGMT CONST_INT COLON . CONST_INT RPAREN instruction_block

    CONST_INT       shift and go to state 197


state 196

    (60) conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .

    RBRACE          reduce using rule 60 (conditional -> IF LPAREN expr RPAREN instruction_block ELSE instruction_block .)


state 197

    (65) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT . COLON CONST_INT RPAREN instruction_block
    (66) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT . RPAREN instruction_block

    COLON           shift and go to state 198
    RPAREN          shift and go to state 199


state 198

    (65) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON . CONST_INT RPAREN instruction_block

    CONST_INT       shift and go to state 200


state 199

    (66) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 201

state 200

    (65) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT . RPAREN instruction_block

    RPAREN          shift and go to state 202


state 201

    (66) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .

    RBRACE          reduce using rule 66 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT RPAREN instruction_block .)


state 202

    (65) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN . instruction_block
    (32) instruction_block -> . LBRACE statements RBRACE
    (33) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 33

    instruction_block              shift and go to state 203

state 203

    (65) for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .

    RBRACE          reduce using rule 65 (for -> FROM LPAREN ID ASGMT CONST_INT COLON CONST_INT COLON CONST_INT RPAREN instruction_block .)

