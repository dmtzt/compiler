
        cls._reserved = {
            "alie": "ELSE",
            "au": "OR",
            "bul": "BOOL",
            "dum": "WHILE",
            "ekde": "FROM",
            "ent": "INT",
            "funkcio": "FUNCTION",
            "komenco": "START",
            "kar": "CHAR",
            "kaj": "AND",
            "legi": "READ",
            "malvera": "BOOL_FALSE",
            "ne": "NOT",
            "reel": "REAL",
            "skribi": "PRINT",
            "se": "IF",
            "tutmondaj": "GLOBAL",
            "variabloj": "VARIABLES", 
            "vera": "BOOL_TRUE",
        }

        cls._operators = {
            "+": "PLUS",
            "-": "MINUS",
            "*": "TIMES",
            "/": "DIVIDE",
            "%": "MODULO",
            "==": "EQUAL",
            "!=": "NEQUAL",
            "<=": "LTHAN_EQUAL",
            ">=": "GTHAN_EQUAL",
            "<": "LTHAN",
            ">": "GTHAN",
            "=": "ASGMT",
            "(": "LPAREN",
            ")": "RPAREN",
            "[": "LBRACKET",
            "]": "RBRACKET",
            "{": "LBRACE",
            "}": "RBRACE",
            ":": "COLON",
            ";": "SEMI",
            ",": "COMMA",
        }

    def getReservedTypes(self):
        return list(self._reserved.values())

    
    def getReservedValues(self):
        return list(self._reserved.keys())

    
    def getOperatorsTypes(self):
        return list(self._operators.values())

    
    def getOperatorsValues(self):
        return list(self._operators.keys())

    
    def joinListAsString(self, l):
        return ' '.join(l)


    def test_lexer_produces_start_token(self):
        testValue = "komenco"
        testType = "START"

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)


    def test_lexer_1(self):
        """Lexer produces 'reserved' tokens"""
        reservedValuesList = self.getReservedValues()
        reservedValuesString = self.joinListAsString(reservedValuesList)

        reservedTypesList = self.getReservedTypes()
        
        tokens = self.lexer.testMultipleTokens(reservedValuesString)
        tokensTypeList = self.lexer.getTokensTypes(tokens)
        
        self.assertCountEqual(reservedTypesList, tokensTypeList)

    
    def test_lexer_produces_operator_tokens(self):
        operatorsValuesList = self.getOperatorsValues()
        operatorsValuesString = self.joinListAsString(operatorsValuesList)

        operatorsTypesList = self.getOperatorsTypes()

        tokens = self.lexer.testMultipleTokens(operatorsValuesString)
        tokensTypeList = self.lexer.getTokensTypes(tokens)

        self.assertCountEqual(operatorsTypesList, tokensTypeList)

    
    def test_lexer_produces_id_only_letters(self):
        testValue = "count"
        testType = "ID"

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)


    def test_lexer_rejects_id_begins_with_digits(self):
        testValue = "1a"

        with self.assertRaises(LexError):
            token = self.lexer.testSingleToken(testValue)
            print(token)

    
    def test_lexer_produces_id_begins_with_letter_ends_with_digits(self):
        testValue = "room123"
        testType = "ID"

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)

    
    def test_lexer_produces_id_begins_with_letter_has_digits_combined(self):
        testValue = "c0mpil3rs"
        testType = "ID"

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)

    
    def test_lexer_produces_const_int(self):
        testValue = "1240"
        testType = "CONST_INT"

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)

    
    def test_lexer_produces_const_float(self):
        testValue = "3.14"
        testType = "CONST_FLOAT"

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)


    def test_lexer_rejects_const_float_only_integer_part(self):
        testValue = "1."

        with self.assertRaises(LexError):
            token = self.lexer.testSingleToken(testValue)
            tokenType = self.lexer.getTokenType(token)
            print(tokenType)


    def test_lexer_rejects_const_float_only_decimal_part(self):
        testValue = ".1"

        with self.assertRaises(LexError):
            self.lexer.testSingleToken(testValue)


    def test_lexer_splits_negative_sign_const_int(self):
        testValue = "-1"
        testTypes = ["MINUS", "CONST_INT"]

        tokens = self.lexer.testMultipleTokens(testValue)
        tokensTypeList = self.lexer.getTokensTypes(tokens)

        self.assertCountEqual(testTypes, tokensTypeList)


    def test_lexer_splits_negative_sign_const_float(self):
        testValue = "-2.15"
        testTypes = ["MINUS", "CONST_FLOAT"]

        tokens = self.lexer.testMultipleTokens(testValue)
        tokensTypeList = self.lexer.getTokensTypes(tokens)

        self.assertCountEqual(testTypes, tokensTypeList)


    def test_lexer_produces_const_int_const_float(self):
        testValue = "10 8.12"
        testTypes = ["CONST_INT", "CONST_FLOAT"]

        tokens = self.lexer.testMultipleTokens(testValue)
        tokensTypeList = self.lexer.getTokensTypes(tokens)

        self.assertCountEqual(testTypes, tokensTypeList)

    
    def test_lexer_produces_lower_char(self):
        testValue = "'a'"
        testType = 'CONST_CHAR'

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)

    
    def test_lexer_produces_upper_char(self):
        testValue = "'A'"
        testType = 'CONST_CHAR'

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)

    
    def test_lexer_produces_digit_char(self):
        testValue = "'1'"
        testType = 'CONST_CHAR'

        token = self.lexer.testSingleToken(testValue)
        tokenType = self.lexer.getTokenType(token)

        self.assertEqual(testType, tokenType)


    def test_lexer_rejects_non_one_sized_char(self):
        testValue = "'1Az'"
        
        with self.assertRaises(LexError):
            self.lexer.testSingleToken(testValue)
    



class IntegerConstantStorageQuadruple():
    def __init__(
        self,
        integer_constant: int,
        storage_variable: Variable,
    ) -> None:
        self._operator = Operator.STORE_CONSTANT
        self._integer_constant = integer_constant
        self._storage_variable = storage_variable

    
    def __str__(self) -> str:
        return f'IntegerConstantStorageQuadruple(op={self._operator} value={self._integer_constant} storage_var={self._storage_variable})'


class RealConstantStorageQuadruple():
    def __init__(
        self,
        real_value: float,
        storage_variable: Variable,
    ) -> None:
        self._operator = Operator.STORE_CONSTANT
        self._real_value = real_value
        self._storage_variable = storage_variable

    
    def __str__(self) -> str:
        return f'RealConstantStorageQuadruple(op={self._operator} value={self._real_value} storage_var={self._storage_variable})'


class BooleanConstantStorageQuadruple():
    def __init__(
        self,
        bool_value: bool,
        storage_variable: Variable,
    ) -> None:
        self._operator = Operator.STORE_CONSTANT
        self._bool_value = bool_value
        self._storage_variable = storage_variable

    
    def __str__(self) -> str:
        return f'CharConstantStorageQuadruple(op={self._operator} value={self._bool_value} storage_var={self._storage_variable})'


class CharacterConstantStorageQuadruple():
    def __init__(
        self,
        char_value: str,
        storage_variable: Variable,
    ) -> None:
        self._operator = Operator.STORE_CONSTANT
        self._char_value = char_value
        self._storage_variable = storage_variable

    
    def __str__(self) -> str:
        return f'CharConstantStorageQuadruple(op={self._operator} value={self._char_value} storage_var={self._storage_variable})'


class StringConstantStorageQuadruple():
    def __init__(
        self,
        str_value: str,
        storage_variable: Variable,
    ) -> None:
        self._operator = Operator.STORE_CONSTANT
        self._str_value = str_value
        self._storage_variable = storage_variable

    
    def __str__(self) -> str:
        return f'CharConstantStorageQuadruple(op={self._operator} value={self._str_value} storage_var={self._storage_variable})'



    
    def insert_integer_constant_storage_quadruple(self, quadruple: IntegerConstantStorageQuadruple) -> None:
        self.quadruple_list.insert_integer_constant_storage_quadruple(quadruple)

    
    def insert_real_constant_storage_quadruple(self, quadruple: RealConstantStorageQuadruple) -> None:
        self.quadruple_list.insert_real_constant_storage_quadruple(quadruple)

    
    def insert_boolean_constant_storage_quadruple(self, quadruple: BooleanConstantStorageQuadruple) -> None:
        self.quadruple_list.insert_boolean_constant_storage_quadruple(quadruple)
    

    def insert_character_constant_storage_quadruple(self, quadruple: CharacterConstantStorageQuadruple) -> None:
        self.quadruple_list.insert_char_constant_storage_quadruple(quadruple)

    
    def insert_string_constant_storage_quadruple(self, quadruple: StringConstantStorageQuadruple) -> None:
        self.quadruple_list.insert_string_constant_storage_quadruple(quadruple)


    
    
    def generate_integer_constant_storage_quadruple(self, integer_constant: str) -> ConstantStorageQuadruple:
        storage_variable_type = Type.INT

        storage_variable = self.create_constant_variable(storage_variable_type)
        self.push_operand_stack(storage_variable)
        self.increment_constant_counter(storage_variable_type)
        
        return ConstantStorageQuadruple(integer_constant, storage_variable)

    
    def generate_real_constant_storage_quadruple(self, real_constant: str) -> RealConstantStorageQuadruple:
        storage_variable_type = Type.REAL

        storage_variable = self.create_constant_variable(storage_variable_type)
        self.push_operand_stack(storage_variable)
        self.increment_constant_counter(storage_variable_type)
        
        return RealConstantStorageQuadruple(real_constant, storage_variable)

    
    def generate_character_constant_storage_quadruple(self, character_constant: str) -> CharacterConstantStorageQuadruple:
        storage_variable_type = Type.CHAR

        storage_variable = self.create_constant_variable(storage_variable_type)
        self.push_operand_stack(storage_variable)
        self.increment_constant_counter(storage_variable_type)
        
        return CharacterConstantStorageQuadruple(character_constant, storage_variable)

    
    def generate_string_constant_storage_quadruple(self, string_constant: str) -> StringConstantStorageQuadruple:
        storage_variable_type = Type.CHAR

        storage_variable = self.create_constant_variable(storage_variable_type)
        self.push_operand_stack(storage_variable)
        self.increment_constant_counter(storage_variable_type)
        
        return StringConstantStorageQuadruple(string_constant, storage_variable)

    

    
        constant_value = p[3]
        constant_type = Type.INT
        constant_variable = self.create_constant_variable(constant_type)
        self.increment_constant_counter(constant_type)

        
        constant_storage_quadruple = self.generate_constant_storage_quadruple(constant_value, constant_variable)
        self.insert_quadruple(constant_storage_quadruple)
        self.increment_program_counter()