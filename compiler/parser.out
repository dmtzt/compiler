Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> init start
Rule 2     init -> <empty>
Rule 3     start -> global_variables_declaration functions_definition entry_point_definition
Rule 4     start -> global_variables_declaration entry_point_definition
Rule 5     start -> functions_definition entry_point_definition
Rule 6     start -> entry_point_definition
Rule 7     global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration
Rule 8     parsed_global_scope -> <empty>
Rule 9     functions_definition -> functions_definition single_function_definition
Rule 10    functions_definition -> single_function_definition
Rule 11    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
Rule 12    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
Rule 13    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
Rule 14    single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
Rule 15    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
Rule 16    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
Rule 17    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
Rule 18    single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block
Rule 19    parsed_type_function_id -> <empty>
Rule 20    parsed_void_function_id -> <empty>
Rule 21    parsed_function_return_type -> <empty>
Rule 22    parsed_function_void_return_type -> <empty>
Rule 23    function_definition_params -> function_definition_params COMMA single_function_definition_param
Rule 24    function_definition_params -> single_function_definition_param
Rule 25    single_function_definition_param -> type ID
Rule 26    entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
Rule 27    entry_point_definition -> START parsed_main_id LPAREN RPAREN instruction_block
Rule 28    parsed_main_id -> <empty>
Rule 29    local_variables_declaration -> LOCAL variables_declaration
Rule 30    variables_declaration -> VARIABLES COLON distinct_type_variables_declaration
Rule 31    distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration
Rule 32    distinct_type_variables_declaration -> shared_type_variables_declaration
Rule 33    shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI
Rule 34    parsed_type -> <empty>
Rule 35    shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration
Rule 36    shared_type_variables_declaration_list -> single_variable_declaration
Rule 37    single_variable_declaration -> ID dim_definition dim_definition
Rule 38    single_variable_declaration -> ID dim_definition
Rule 39    single_variable_declaration -> ID
Rule 40    dim_definition -> LBRACKET CONST_INT RBRACKET
Rule 41    instruction_block -> LBRACE statements RBRACE
Rule 42    instruction_block -> LBRACE RBRACE
Rule 43    statements -> statements single_statement
Rule 44    statements -> single_statement
Rule 45    single_statement -> assignment
Rule 46    single_statement -> function_call_stmt
Rule 47    single_statement -> print
Rule 48    single_statement -> conditional
Rule 49    single_statement -> loop
Rule 50    single_statement -> return
Rule 51    assignment -> variable_access ASGMT expr SEMI
Rule 52    assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI
Rule 53    variable_access -> ID parsed_id_variable_access dims_access
Rule 54    parsed_id_variable_access -> <empty>
Rule 55    dims_access -> single_dim_access single_dim_access
Rule 56    dims_access -> single_dim_access
Rule 57    dims_access -> empty
Rule 58    single_dim_access -> LBRACKET expr RBRACKET
Rule 59    function_call_stmt -> function_call SEMI
Rule 60    function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN
Rule 61    function_call -> ID parsed_function_call_id LPAREN RPAREN
Rule 62    parsed_function_call_id -> <empty>
Rule 63    function_call_params -> function_call_params COMMA single_function_call_param
Rule 64    function_call_params -> single_function_call_param
Rule 65    single_function_call_param -> expr
Rule 66    print -> PRINT LPAREN print_params RPAREN SEMI
Rule 67    print -> PRINT LPAREN RPAREN SEMI
Rule 68    print_params -> print_params COMMA single_print_param
Rule 69    print_params -> single_print_param
Rule 70    single_print_param -> expr
Rule 71    conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block
Rule 72    conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block
Rule 73    parsed_if_expr -> <empty>
Rule 74    parsed_else -> <empty>
Rule 75    loop -> while
Rule 76    loop -> for
Rule 77    while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block
Rule 78    parsed_while -> <empty>
Rule 79    parsed_while_expr -> <empty>
Rule 80    for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block
Rule 81    for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block
Rule 82    for_index -> ID ASGMT CONST_INT
Rule 83    for_index -> ID ASGMT MINUS CONST_INT
Rule 84    for_limit -> CONST_INT
Rule 85    for_limit -> MINUS CONST_INT
Rule 86    for_no_step -> <empty>
Rule 87    for_step -> CONST_INT
Rule 88    for_step -> MINUS CONST_INT
Rule 89    return -> RETURN expr SEMI
Rule 90    return -> RETURN SEMI
Rule 91    expr -> expr OR and_expr
Rule 92    expr -> and_expr
Rule 93    and_expr -> equality_expr AND equality_expr
Rule 94    and_expr -> equality_expr
Rule 95    equality_expr -> relational_expr EQUAL parsed_equal relational_expr
Rule 96    parsed_equal -> <empty>
Rule 97    equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr
Rule 98    parsed_nequal -> <empty>
Rule 99    equality_expr -> relational_expr
Rule 100   relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
Rule 101   parsed_lthan_equal -> <empty>
Rule 102   relational_expr -> additive_expr LTHAN parsed_lthan additive_expr
Rule 103   parsed_lthan -> <empty>
Rule 104   relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
Rule 105   parsed_gthan_equal -> <empty>
Rule 106   relational_expr -> additive_expr GTHAN parsed_gthan additive_expr
Rule 107   parsed_gthan -> <empty>
Rule 108   relational_expr -> additive_expr
Rule 109   additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr
Rule 110   parsed_plus -> <empty>
Rule 111   additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr
Rule 112   parsed_minus -> <empty>
Rule 113   additive_expr -> multiplicative_expr
Rule 114   multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr
Rule 115   parsed_times -> <empty>
Rule 116   multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr
Rule 117   parsed_divide -> <empty>
Rule 118   multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr
Rule 119   parsed_modulo -> <empty>
Rule 120   multiplicative_expr -> unary_expr
Rule 121   unary_expr -> MINUS postfix_expr
Rule 122   unary_expr -> PLUS postfix_expr
Rule 123   unary_expr -> NOT postfix_expr
Rule 124   unary_expr -> postfix_expr
Rule 125   postfix_expr -> LPAREN expr RPAREN
Rule 126   postfix_expr -> variable_access
Rule 127   postfix_expr -> function_call
Rule 128   postfix_expr -> constant
Rule 129   constant -> CONST_INT
Rule 130   constant -> CONST_REAL
Rule 131   constant -> CONST_CHAR
Rule 132   constant -> CONST_STRING
Rule 133   constant -> constant_bool
Rule 134   constant_bool -> TRUE
Rule 135   constant_bool -> FALSE
Rule 136   type -> INT
Rule 137   type -> REAL
Rule 138   type -> CHAR
Rule 139   type -> BOOL
Rule 140   empty -> <empty>

Terminals, with rules where they appear

AND                  : 93
ASGMT                : 51 52 82 83
BOOL                 : 139
CHAR                 : 138
COLON                : 30 80 80 81
COMMA                : 23 35 63 68
CONST_CHAR           : 131
CONST_INT            : 40 82 83 84 85 87 88 129
CONST_REAL           : 130
CONST_STRING         : 132
DIVIDE               : 116
ELSE                 : 71
EQUAL                : 95
FALSE                : 135
FROM                 : 80 81
FUNCTION             : 11 12 13 14 15 16 17 18
GLOBAL               : 7
GTHAN                : 106
GTHAN_EQUAL          : 104
ID                   : 11 12 13 14 15 16 17 18 25 37 38 39 53 60 61 82 83
IF                   : 71 72
INT                  : 136
LBRACE               : 41 42
LBRACKET             : 40 58
LOCAL                : 29
LPAREN               : 11 12 13 14 15 16 17 18 26 27 52 60 61 66 67 71 72 77 80 81 125
LTHAN                : 102
LTHAN_EQUAL          : 100
MINUS                : 83 85 88 111 121
MODULO               : 118
NEQUAL               : 97
NOT                  : 123
OR                   : 91
PLUS                 : 109 122
PRINT                : 66 67
RBRACE               : 41 42
RBRACKET             : 40 58
READ                 : 52
REAL                 : 137
RETURN               : 89 90
RPAREN               : 11 12 13 14 15 16 17 18 26 27 52 60 61 66 67 71 72 77 80 81 125
SEMI                 : 33 51 52 59 66 67 89 90
START                : 26 27
TIMES                : 114
TRUE                 : 134
VARIABLES            : 30
VOID                 : 15 16 17 18
WHILE                : 77
error                : 

Nonterminals, with rules where they appear

additive_expr        : 100 100 102 102 104 104 106 106 108 109 111
and_expr             : 91 92
assignment           : 45
conditional          : 48
constant             : 128
constant_bool        : 133
dim_definition       : 37 37 38
dims_access          : 53
distinct_type_variables_declaration : 30 31
empty                : 57
entry_point_definition : 3 4 5 6
equality_expr        : 93 93 94
expr                 : 51 58 65 70 71 72 77 89 91 125
for                  : 76
for_index            : 80 81
for_limit            : 80 81
for_no_step          : 81
for_step             : 80
function_call        : 59 127
function_call_params : 60 63
function_call_stmt   : 46
function_definition_params : 11 12 15 16 23
functions_definition : 3 5 9
global_variables_declaration : 3 4
init                 : 1
instruction_block    : 11 12 13 14 15 16 17 18 26 27 71 71 72 77 80 81
local_variables_declaration : 11 13 15 17 26
loop                 : 49
multiplicative_expr  : 109 111 113 114 116 118
parsed_divide        : 116
parsed_else          : 71
parsed_equal         : 95
parsed_function_call_id : 60 61
parsed_function_return_type : 11 12 13 14
parsed_function_void_return_type : 15 16 17 18
parsed_global_scope  : 7
parsed_gthan         : 106
parsed_gthan_equal   : 104
parsed_id_variable_access : 53
parsed_if_expr       : 71 72
parsed_lthan         : 102
parsed_lthan_equal   : 100
parsed_main_id       : 26 27
parsed_minus         : 111
parsed_modulo        : 118
parsed_nequal        : 97
parsed_plus          : 109
parsed_times         : 114
parsed_type          : 33
parsed_type_function_id : 11 12 13 14
parsed_void_function_id : 15 16 17 18
parsed_while         : 77
parsed_while_expr    : 77
postfix_expr         : 121 122 123 124
print                : 47
print_params         : 66 68
program              : 0
relational_expr      : 95 95 97 97 99
return               : 50
shared_type_variables_declaration : 31 32
shared_type_variables_declaration_list : 33 35
single_dim_access    : 55 55 56
single_function_call_param : 63 64
single_function_definition : 9 10
single_function_definition_param : 23 24
single_print_param   : 68 69
single_statement     : 43 44
single_variable_declaration : 35 36
start                : 1
statements           : 41 43
type                 : 11 12 13 14 25 33
unary_expr           : 114 116 118 120
variable_access      : 51 52 126
variables_declaration : 7 29
while                : 75

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . init start
    (2) init -> .

    GLOBAL          reduce using rule 2 (init -> .)
    START           reduce using rule 2 (init -> .)
    FUNCTION        reduce using rule 2 (init -> .)

    program                        shift and go to state 1
    init                           shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> init . start
    (3) start -> . global_variables_declaration functions_definition entry_point_definition
    (4) start -> . global_variables_declaration entry_point_definition
    (5) start -> . functions_definition entry_point_definition
    (6) start -> . entry_point_definition
    (7) global_variables_declaration -> . GLOBAL parsed_global_scope variables_declaration
    (9) functions_definition -> . functions_definition single_function_definition
    (10) functions_definition -> . single_function_definition
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block

    GLOBAL          shift and go to state 7
    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    start                          shift and go to state 3
    global_variables_declaration   shift and go to state 4
    functions_definition           shift and go to state 5
    entry_point_definition         shift and go to state 6
    single_function_definition     shift and go to state 8

state 3

    (1) program -> init start .

    $end            reduce using rule 1 (program -> init start .)


state 4

    (3) start -> global_variables_declaration . functions_definition entry_point_definition
    (4) start -> global_variables_declaration . entry_point_definition
    (9) functions_definition -> . functions_definition single_function_definition
    (10) functions_definition -> . single_function_definition
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block

    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    functions_definition           shift and go to state 11
    entry_point_definition         shift and go to state 12
    single_function_definition     shift and go to state 8

state 5

    (5) start -> functions_definition . entry_point_definition
    (9) functions_definition -> functions_definition . single_function_definition
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block

    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    entry_point_definition         shift and go to state 13
    single_function_definition     shift and go to state 14

state 6

    (6) start -> entry_point_definition .

    $end            reduce using rule 6 (start -> entry_point_definition .)


state 7

    (7) global_variables_declaration -> GLOBAL . parsed_global_scope variables_declaration
    (8) parsed_global_scope -> .

    VARIABLES       reduce using rule 8 (parsed_global_scope -> .)

    parsed_global_scope            shift and go to state 15

state 8

    (10) functions_definition -> single_function_definition .

    START           reduce using rule 10 (functions_definition -> single_function_definition .)
    FUNCTION        reduce using rule 10 (functions_definition -> single_function_definition .)


state 9

    (26) entry_point_definition -> START . parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> START . parsed_main_id LPAREN RPAREN instruction_block
    (28) parsed_main_id -> .

    LPAREN          reduce using rule 28 (parsed_main_id -> .)

    parsed_main_id                 shift and go to state 16

state 10

    (11) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION . type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION . VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block
    (136) type -> . INT
    (137) type -> . REAL
    (138) type -> . CHAR
    (139) type -> . BOOL

    VOID            shift and go to state 18
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    type                           shift and go to state 17

state 11

    (3) start -> global_variables_declaration functions_definition . entry_point_definition
    (9) functions_definition -> functions_definition . single_function_definition
    (26) entry_point_definition -> . START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> . START parsed_main_id LPAREN RPAREN instruction_block
    (11) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> . FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
    (15) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> . FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block

    START           shift and go to state 9
    FUNCTION        shift and go to state 10

    entry_point_definition         shift and go to state 23
    single_function_definition     shift and go to state 14

state 12

    (4) start -> global_variables_declaration entry_point_definition .

    $end            reduce using rule 4 (start -> global_variables_declaration entry_point_definition .)


state 13

    (5) start -> functions_definition entry_point_definition .

    $end            reduce using rule 5 (start -> functions_definition entry_point_definition .)


state 14

    (9) functions_definition -> functions_definition single_function_definition .

    START           reduce using rule 9 (functions_definition -> functions_definition single_function_definition .)
    FUNCTION        reduce using rule 9 (functions_definition -> functions_definition single_function_definition .)


state 15

    (7) global_variables_declaration -> GLOBAL parsed_global_scope . variables_declaration
    (30) variables_declaration -> . VARIABLES COLON distinct_type_variables_declaration

    VARIABLES       shift and go to state 25

    variables_declaration          shift and go to state 24

state 16

    (26) entry_point_definition -> START parsed_main_id . LPAREN RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> START parsed_main_id . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 26


state 17

    (11) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type . parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block
    (21) parsed_function_return_type -> .

    ID              reduce using rule 21 (parsed_function_return_type -> .)

    parsed_function_return_type    shift and go to state 27

state 18

    (15) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID . parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block
    (22) parsed_function_void_return_type -> .

    ID              reduce using rule 22 (parsed_function_void_return_type -> .)

    parsed_function_void_return_type shift and go to state 28

state 19

    (136) type -> INT .

    ID              reduce using rule 136 (type -> INT .)


state 20

    (137) type -> REAL .

    ID              reduce using rule 137 (type -> REAL .)


state 21

    (138) type -> CHAR .

    ID              reduce using rule 138 (type -> CHAR .)


state 22

    (139) type -> BOOL .

    ID              reduce using rule 139 (type -> BOOL .)


state 23

    (3) start -> global_variables_declaration functions_definition entry_point_definition .

    $end            reduce using rule 3 (start -> global_variables_declaration functions_definition entry_point_definition .)


state 24

    (7) global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration .

    START           reduce using rule 7 (global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration .)
    FUNCTION        reduce using rule 7 (global_variables_declaration -> GLOBAL parsed_global_scope variables_declaration .)


state 25

    (30) variables_declaration -> VARIABLES . COLON distinct_type_variables_declaration

    COLON           shift and go to state 29


state 26

    (26) entry_point_definition -> START parsed_main_id LPAREN . RPAREN local_variables_declaration instruction_block
    (27) entry_point_definition -> START parsed_main_id LPAREN . RPAREN instruction_block

    RPAREN          shift and go to state 30


state 27

    (11) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type . ID parsed_type_function_id LPAREN RPAREN instruction_block

    ID              shift and go to state 31


state 28

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type . ID parsed_void_function_id LPAREN RPAREN instruction_block

    ID              shift and go to state 32


state 29

    (30) variables_declaration -> VARIABLES COLON . distinct_type_variables_declaration
    (31) distinct_type_variables_declaration -> . distinct_type_variables_declaration shared_type_variables_declaration
    (32) distinct_type_variables_declaration -> . shared_type_variables_declaration
    (33) shared_type_variables_declaration -> . type parsed_type shared_type_variables_declaration_list SEMI
    (136) type -> . INT
    (137) type -> . REAL
    (138) type -> . CHAR
    (139) type -> . BOOL

    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    distinct_type_variables_declaration shift and go to state 33
    shared_type_variables_declaration shift and go to state 34
    type                           shift and go to state 35

state 30

    (26) entry_point_definition -> START parsed_main_id LPAREN RPAREN . local_variables_declaration instruction_block
    (27) entry_point_definition -> START parsed_main_id LPAREN RPAREN . instruction_block
    (29) local_variables_declaration -> . LOCAL variables_declaration
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 36
    instruction_block              shift and go to state 37

state 31

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID . parsed_type_function_id LPAREN RPAREN instruction_block
    (19) parsed_type_function_id -> .

    LPAREN          reduce using rule 19 (parsed_type_function_id -> .)

    parsed_type_function_id        shift and go to state 40

state 32

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID . parsed_void_function_id LPAREN RPAREN instruction_block
    (20) parsed_void_function_id -> .

    LPAREN          reduce using rule 20 (parsed_void_function_id -> .)

    parsed_void_function_id        shift and go to state 41

state 33

    (30) variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .
    (31) distinct_type_variables_declaration -> distinct_type_variables_declaration . shared_type_variables_declaration
    (33) shared_type_variables_declaration -> . type parsed_type shared_type_variables_declaration_list SEMI
    (136) type -> . INT
    (137) type -> . REAL
    (138) type -> . CHAR
    (139) type -> . BOOL

    START           reduce using rule 30 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    FUNCTION        reduce using rule 30 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    LBRACE          reduce using rule 30 (variables_declaration -> VARIABLES COLON distinct_type_variables_declaration .)
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    shared_type_variables_declaration shift and go to state 42
    type                           shift and go to state 35

state 34

    (32) distinct_type_variables_declaration -> shared_type_variables_declaration .

    INT             reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    REAL            reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    CHAR            reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    BOOL            reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    START           reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    FUNCTION        reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)
    LBRACE          reduce using rule 32 (distinct_type_variables_declaration -> shared_type_variables_declaration .)


state 35

    (33) shared_type_variables_declaration -> type . parsed_type shared_type_variables_declaration_list SEMI
    (34) parsed_type -> .

    ID              reduce using rule 34 (parsed_type -> .)

    parsed_type                    shift and go to state 43

state 36

    (26) entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 44

state 37

    (27) entry_point_definition -> START parsed_main_id LPAREN RPAREN instruction_block .

    $end            reduce using rule 27 (entry_point_definition -> START parsed_main_id LPAREN RPAREN instruction_block .)


state 38

    (29) local_variables_declaration -> LOCAL . variables_declaration
    (30) variables_declaration -> . VARIABLES COLON distinct_type_variables_declaration

    VARIABLES       shift and go to state 25

    variables_declaration          shift and go to state 45

state 39

    (41) instruction_block -> LBRACE . statements RBRACE
    (42) instruction_block -> LBRACE . RBRACE
    (43) statements -> . statements single_statement
    (44) statements -> . single_statement
    (45) single_statement -> . assignment
    (46) single_statement -> . function_call_stmt
    (47) single_statement -> . print
    (48) single_statement -> . conditional
    (49) single_statement -> . loop
    (50) single_statement -> . return
    (51) assignment -> . variable_access ASGMT expr SEMI
    (52) assignment -> . variable_access ASGMT READ LPAREN RPAREN SEMI
    (59) function_call_stmt -> . function_call SEMI
    (66) print -> . PRINT LPAREN print_params RPAREN SEMI
    (67) print -> . PRINT LPAREN RPAREN SEMI
    (71) conditional -> . IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block
    (72) conditional -> . IF LPAREN expr RPAREN parsed_if_expr instruction_block
    (75) loop -> . while
    (76) loop -> . for
    (89) return -> . RETURN expr SEMI
    (90) return -> . RETURN SEMI
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (77) while -> . WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block
    (80) for -> . FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block
    (81) for -> . FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block

    RBRACE          shift and go to state 47
    PRINT           shift and go to state 57
    IF              shift and go to state 58
    RETURN          shift and go to state 61
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    FROM            shift and go to state 64

    statements                     shift and go to state 46
    single_statement               shift and go to state 48
    assignment                     shift and go to state 49
    function_call_stmt             shift and go to state 50
    print                          shift and go to state 51
    conditional                    shift and go to state 52
    loop                           shift and go to state 53
    return                         shift and go to state 54
    variable_access                shift and go to state 55
    function_call                  shift and go to state 56
    while                          shift and go to state 59
    for                            shift and go to state 60

state 40

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id . LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id . LPAREN function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id . LPAREN RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 65


state 41

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id . LPAREN function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id . LPAREN function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id . LPAREN RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id . LPAREN RPAREN instruction_block

    LPAREN          shift and go to state 66


state 42

    (31) distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .

    INT             reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    REAL            reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    CHAR            reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    BOOL            reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    START           reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    FUNCTION        reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)
    LBRACE          reduce using rule 31 (distinct_type_variables_declaration -> distinct_type_variables_declaration shared_type_variables_declaration .)


state 43

    (33) shared_type_variables_declaration -> type parsed_type . shared_type_variables_declaration_list SEMI
    (35) shared_type_variables_declaration_list -> . shared_type_variables_declaration_list COMMA single_variable_declaration
    (36) shared_type_variables_declaration_list -> . single_variable_declaration
    (37) single_variable_declaration -> . ID dim_definition dim_definition
    (38) single_variable_declaration -> . ID dim_definition
    (39) single_variable_declaration -> . ID

    ID              shift and go to state 69

    shared_type_variables_declaration_list shift and go to state 67
    single_variable_declaration    shift and go to state 68

state 44

    (26) entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block .

    $end            reduce using rule 26 (entry_point_definition -> START parsed_main_id LPAREN RPAREN local_variables_declaration instruction_block .)


state 45

    (29) local_variables_declaration -> LOCAL variables_declaration .

    LBRACE          reduce using rule 29 (local_variables_declaration -> LOCAL variables_declaration .)


state 46

    (41) instruction_block -> LBRACE statements . RBRACE
    (43) statements -> statements . single_statement
    (45) single_statement -> . assignment
    (46) single_statement -> . function_call_stmt
    (47) single_statement -> . print
    (48) single_statement -> . conditional
    (49) single_statement -> . loop
    (50) single_statement -> . return
    (51) assignment -> . variable_access ASGMT expr SEMI
    (52) assignment -> . variable_access ASGMT READ LPAREN RPAREN SEMI
    (59) function_call_stmt -> . function_call SEMI
    (66) print -> . PRINT LPAREN print_params RPAREN SEMI
    (67) print -> . PRINT LPAREN RPAREN SEMI
    (71) conditional -> . IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block
    (72) conditional -> . IF LPAREN expr RPAREN parsed_if_expr instruction_block
    (75) loop -> . while
    (76) loop -> . for
    (89) return -> . RETURN expr SEMI
    (90) return -> . RETURN SEMI
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (77) while -> . WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block
    (80) for -> . FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block
    (81) for -> . FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block

    RBRACE          shift and go to state 70
    PRINT           shift and go to state 57
    IF              shift and go to state 58
    RETURN          shift and go to state 61
    ID              shift and go to state 62
    WHILE           shift and go to state 63
    FROM            shift and go to state 64

    single_statement               shift and go to state 71
    assignment                     shift and go to state 49
    function_call_stmt             shift and go to state 50
    print                          shift and go to state 51
    conditional                    shift and go to state 52
    loop                           shift and go to state 53
    return                         shift and go to state 54
    variable_access                shift and go to state 55
    function_call                  shift and go to state 56
    while                          shift and go to state 59
    for                            shift and go to state 60

state 47

    (42) instruction_block -> LBRACE RBRACE .

    $end            reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    START           reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    ELSE            reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    PRINT           reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    IF              reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    RETURN          reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    ID              reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    WHILE           reduce using rule 42 (instruction_block -> LBRACE RBRACE .)
    FROM            reduce using rule 42 (instruction_block -> LBRACE RBRACE .)


state 48

    (44) statements -> single_statement .

    RBRACE          reduce using rule 44 (statements -> single_statement .)
    PRINT           reduce using rule 44 (statements -> single_statement .)
    IF              reduce using rule 44 (statements -> single_statement .)
    RETURN          reduce using rule 44 (statements -> single_statement .)
    ID              reduce using rule 44 (statements -> single_statement .)
    WHILE           reduce using rule 44 (statements -> single_statement .)
    FROM            reduce using rule 44 (statements -> single_statement .)


state 49

    (45) single_statement -> assignment .

    RBRACE          reduce using rule 45 (single_statement -> assignment .)
    PRINT           reduce using rule 45 (single_statement -> assignment .)
    IF              reduce using rule 45 (single_statement -> assignment .)
    RETURN          reduce using rule 45 (single_statement -> assignment .)
    ID              reduce using rule 45 (single_statement -> assignment .)
    WHILE           reduce using rule 45 (single_statement -> assignment .)
    FROM            reduce using rule 45 (single_statement -> assignment .)


state 50

    (46) single_statement -> function_call_stmt .

    RBRACE          reduce using rule 46 (single_statement -> function_call_stmt .)
    PRINT           reduce using rule 46 (single_statement -> function_call_stmt .)
    IF              reduce using rule 46 (single_statement -> function_call_stmt .)
    RETURN          reduce using rule 46 (single_statement -> function_call_stmt .)
    ID              reduce using rule 46 (single_statement -> function_call_stmt .)
    WHILE           reduce using rule 46 (single_statement -> function_call_stmt .)
    FROM            reduce using rule 46 (single_statement -> function_call_stmt .)


state 51

    (47) single_statement -> print .

    RBRACE          reduce using rule 47 (single_statement -> print .)
    PRINT           reduce using rule 47 (single_statement -> print .)
    IF              reduce using rule 47 (single_statement -> print .)
    RETURN          reduce using rule 47 (single_statement -> print .)
    ID              reduce using rule 47 (single_statement -> print .)
    WHILE           reduce using rule 47 (single_statement -> print .)
    FROM            reduce using rule 47 (single_statement -> print .)


state 52

    (48) single_statement -> conditional .

    RBRACE          reduce using rule 48 (single_statement -> conditional .)
    PRINT           reduce using rule 48 (single_statement -> conditional .)
    IF              reduce using rule 48 (single_statement -> conditional .)
    RETURN          reduce using rule 48 (single_statement -> conditional .)
    ID              reduce using rule 48 (single_statement -> conditional .)
    WHILE           reduce using rule 48 (single_statement -> conditional .)
    FROM            reduce using rule 48 (single_statement -> conditional .)


state 53

    (49) single_statement -> loop .

    RBRACE          reduce using rule 49 (single_statement -> loop .)
    PRINT           reduce using rule 49 (single_statement -> loop .)
    IF              reduce using rule 49 (single_statement -> loop .)
    RETURN          reduce using rule 49 (single_statement -> loop .)
    ID              reduce using rule 49 (single_statement -> loop .)
    WHILE           reduce using rule 49 (single_statement -> loop .)
    FROM            reduce using rule 49 (single_statement -> loop .)


state 54

    (50) single_statement -> return .

    RBRACE          reduce using rule 50 (single_statement -> return .)
    PRINT           reduce using rule 50 (single_statement -> return .)
    IF              reduce using rule 50 (single_statement -> return .)
    RETURN          reduce using rule 50 (single_statement -> return .)
    ID              reduce using rule 50 (single_statement -> return .)
    WHILE           reduce using rule 50 (single_statement -> return .)
    FROM            reduce using rule 50 (single_statement -> return .)


state 55

    (51) assignment -> variable_access . ASGMT expr SEMI
    (52) assignment -> variable_access . ASGMT READ LPAREN RPAREN SEMI

    ASGMT           shift and go to state 72


state 56

    (59) function_call_stmt -> function_call . SEMI

    SEMI            shift and go to state 73


state 57

    (66) print -> PRINT . LPAREN print_params RPAREN SEMI
    (67) print -> PRINT . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 74


state 58

    (71) conditional -> IF . LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block
    (72) conditional -> IF . LPAREN expr RPAREN parsed_if_expr instruction_block

    LPAREN          shift and go to state 75


state 59

    (75) loop -> while .

    RBRACE          reduce using rule 75 (loop -> while .)
    PRINT           reduce using rule 75 (loop -> while .)
    IF              reduce using rule 75 (loop -> while .)
    RETURN          reduce using rule 75 (loop -> while .)
    ID              reduce using rule 75 (loop -> while .)
    WHILE           reduce using rule 75 (loop -> while .)
    FROM            reduce using rule 75 (loop -> while .)


state 60

    (76) loop -> for .

    RBRACE          reduce using rule 76 (loop -> for .)
    PRINT           reduce using rule 76 (loop -> for .)
    IF              reduce using rule 76 (loop -> for .)
    RETURN          reduce using rule 76 (loop -> for .)
    ID              reduce using rule 76 (loop -> for .)
    WHILE           reduce using rule 76 (loop -> for .)
    FROM            reduce using rule 76 (loop -> for .)


state 61

    (89) return -> RETURN . expr SEMI
    (90) return -> RETURN . SEMI
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    SEMI            shift and go to state 77
    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expr                           shift and go to state 76
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 62

    (53) variable_access -> ID . parsed_id_variable_access dims_access
    (60) function_call -> ID . parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> ID . parsed_function_call_id LPAREN RPAREN
    (54) parsed_id_variable_access -> .
    (62) parsed_function_call_id -> .

    LBRACKET        reduce using rule 54 (parsed_id_variable_access -> .)
    ASGMT           reduce using rule 54 (parsed_id_variable_access -> .)
    TIMES           reduce using rule 54 (parsed_id_variable_access -> .)
    DIVIDE          reduce using rule 54 (parsed_id_variable_access -> .)
    MODULO          reduce using rule 54 (parsed_id_variable_access -> .)
    LTHAN_EQUAL     reduce using rule 54 (parsed_id_variable_access -> .)
    LTHAN           reduce using rule 54 (parsed_id_variable_access -> .)
    GTHAN_EQUAL     reduce using rule 54 (parsed_id_variable_access -> .)
    GTHAN           reduce using rule 54 (parsed_id_variable_access -> .)
    PLUS            reduce using rule 54 (parsed_id_variable_access -> .)
    MINUS           reduce using rule 54 (parsed_id_variable_access -> .)
    EQUAL           reduce using rule 54 (parsed_id_variable_access -> .)
    NEQUAL          reduce using rule 54 (parsed_id_variable_access -> .)
    AND             reduce using rule 54 (parsed_id_variable_access -> .)
    SEMI            reduce using rule 54 (parsed_id_variable_access -> .)
    OR              reduce using rule 54 (parsed_id_variable_access -> .)
    RPAREN          reduce using rule 54 (parsed_id_variable_access -> .)
    COMMA           reduce using rule 54 (parsed_id_variable_access -> .)
    RBRACKET        reduce using rule 54 (parsed_id_variable_access -> .)
    LPAREN          reduce using rule 62 (parsed_function_call_id -> .)

    parsed_id_variable_access      shift and go to state 99
    parsed_function_call_id        shift and go to state 100

state 63

    (77) while -> WHILE . parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block
    (78) parsed_while -> .

    LPAREN          reduce using rule 78 (parsed_while -> .)

    parsed_while                   shift and go to state 101

state 64

    (80) for -> FROM . LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block
    (81) for -> FROM . LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block

    LPAREN          shift and go to state 102


state 65

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN . function_definition_params RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN . function_definition_params RPAREN instruction_block
    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN . RPAREN local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN . RPAREN instruction_block
    (23) function_definition_params -> . function_definition_params COMMA single_function_definition_param
    (24) function_definition_params -> . single_function_definition_param
    (25) single_function_definition_param -> . type ID
    (136) type -> . INT
    (137) type -> . REAL
    (138) type -> . CHAR
    (139) type -> . BOOL

    RPAREN          shift and go to state 105
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    type                           shift and go to state 103
    function_definition_params     shift and go to state 104
    single_function_definition_param shift and go to state 106

state 66

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN . function_definition_params RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN . function_definition_params RPAREN instruction_block
    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN . RPAREN local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN . RPAREN instruction_block
    (23) function_definition_params -> . function_definition_params COMMA single_function_definition_param
    (24) function_definition_params -> . single_function_definition_param
    (25) single_function_definition_param -> . type ID
    (136) type -> . INT
    (137) type -> . REAL
    (138) type -> . CHAR
    (139) type -> . BOOL

    RPAREN          shift and go to state 108
    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    function_definition_params     shift and go to state 107
    single_function_definition_param shift and go to state 106
    type                           shift and go to state 103

state 67

    (33) shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list . SEMI
    (35) shared_type_variables_declaration_list -> shared_type_variables_declaration_list . COMMA single_variable_declaration

    SEMI            shift and go to state 109
    COMMA           shift and go to state 110


state 68

    (36) shared_type_variables_declaration_list -> single_variable_declaration .

    SEMI            reduce using rule 36 (shared_type_variables_declaration_list -> single_variable_declaration .)
    COMMA           reduce using rule 36 (shared_type_variables_declaration_list -> single_variable_declaration .)


state 69

    (37) single_variable_declaration -> ID . dim_definition dim_definition
    (38) single_variable_declaration -> ID . dim_definition
    (39) single_variable_declaration -> ID .
    (40) dim_definition -> . LBRACKET CONST_INT RBRACKET

    SEMI            reduce using rule 39 (single_variable_declaration -> ID .)
    COMMA           reduce using rule 39 (single_variable_declaration -> ID .)
    LBRACKET        shift and go to state 112

    dim_definition                 shift and go to state 111

state 70

    (41) instruction_block -> LBRACE statements RBRACE .

    $end            reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    START           reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    FUNCTION        reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    PRINT           reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    IF              reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    ID              reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)
    FROM            reduce using rule 41 (instruction_block -> LBRACE statements RBRACE .)


state 71

    (43) statements -> statements single_statement .

    RBRACE          reduce using rule 43 (statements -> statements single_statement .)
    PRINT           reduce using rule 43 (statements -> statements single_statement .)
    IF              reduce using rule 43 (statements -> statements single_statement .)
    RETURN          reduce using rule 43 (statements -> statements single_statement .)
    ID              reduce using rule 43 (statements -> statements single_statement .)
    WHILE           reduce using rule 43 (statements -> statements single_statement .)
    FROM            reduce using rule 43 (statements -> statements single_statement .)


state 72

    (51) assignment -> variable_access ASGMT . expr SEMI
    (52) assignment -> variable_access ASGMT . READ LPAREN RPAREN SEMI
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    READ            shift and go to state 114
    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    variable_access                shift and go to state 89
    expr                           shift and go to state 113
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 73

    (59) function_call_stmt -> function_call SEMI .

    RBRACE          reduce using rule 59 (function_call_stmt -> function_call SEMI .)
    PRINT           reduce using rule 59 (function_call_stmt -> function_call SEMI .)
    IF              reduce using rule 59 (function_call_stmt -> function_call SEMI .)
    RETURN          reduce using rule 59 (function_call_stmt -> function_call SEMI .)
    ID              reduce using rule 59 (function_call_stmt -> function_call SEMI .)
    WHILE           reduce using rule 59 (function_call_stmt -> function_call SEMI .)
    FROM            reduce using rule 59 (function_call_stmt -> function_call SEMI .)


state 74

    (66) print -> PRINT LPAREN . print_params RPAREN SEMI
    (67) print -> PRINT LPAREN . RPAREN SEMI
    (68) print_params -> . print_params COMMA single_print_param
    (69) print_params -> . single_print_param
    (70) single_print_param -> . expr
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    RPAREN          shift and go to state 116
    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    print_params                   shift and go to state 115
    single_print_param             shift and go to state 117
    expr                           shift and go to state 118
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 75

    (71) conditional -> IF LPAREN . expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block
    (72) conditional -> IF LPAREN . expr RPAREN parsed_if_expr instruction_block
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expr                           shift and go to state 119
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 76

    (89) return -> RETURN expr . SEMI
    (91) expr -> expr . OR and_expr

    SEMI            shift and go to state 120
    OR              shift and go to state 121


state 77

    (90) return -> RETURN SEMI .

    RBRACE          reduce using rule 90 (return -> RETURN SEMI .)
    PRINT           reduce using rule 90 (return -> RETURN SEMI .)
    IF              reduce using rule 90 (return -> RETURN SEMI .)
    RETURN          reduce using rule 90 (return -> RETURN SEMI .)
    ID              reduce using rule 90 (return -> RETURN SEMI .)
    WHILE           reduce using rule 90 (return -> RETURN SEMI .)
    FROM            reduce using rule 90 (return -> RETURN SEMI .)


state 78

    (92) expr -> and_expr .

    SEMI            reduce using rule 92 (expr -> and_expr .)
    OR              reduce using rule 92 (expr -> and_expr .)
    RPAREN          reduce using rule 92 (expr -> and_expr .)
    COMMA           reduce using rule 92 (expr -> and_expr .)
    RBRACKET        reduce using rule 92 (expr -> and_expr .)


state 79

    (93) and_expr -> equality_expr . AND equality_expr
    (94) and_expr -> equality_expr .

    AND             shift and go to state 122
    SEMI            reduce using rule 94 (and_expr -> equality_expr .)
    OR              reduce using rule 94 (and_expr -> equality_expr .)
    RPAREN          reduce using rule 94 (and_expr -> equality_expr .)
    COMMA           reduce using rule 94 (and_expr -> equality_expr .)
    RBRACKET        reduce using rule 94 (and_expr -> equality_expr .)


state 80

    (95) equality_expr -> relational_expr . EQUAL parsed_equal relational_expr
    (97) equality_expr -> relational_expr . NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> relational_expr .

    EQUAL           shift and go to state 123
    NEQUAL          shift and go to state 124
    AND             reduce using rule 99 (equality_expr -> relational_expr .)
    SEMI            reduce using rule 99 (equality_expr -> relational_expr .)
    OR              reduce using rule 99 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 99 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 99 (equality_expr -> relational_expr .)
    RBRACKET        reduce using rule 99 (equality_expr -> relational_expr .)


state 81

    (100) relational_expr -> additive_expr . LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> additive_expr . LTHAN parsed_lthan additive_expr
    (104) relational_expr -> additive_expr . GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> additive_expr . GTHAN parsed_gthan additive_expr
    (108) relational_expr -> additive_expr .
    (109) additive_expr -> additive_expr . PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> additive_expr . MINUS parsed_minus multiplicative_expr

    LTHAN_EQUAL     shift and go to state 125
    LTHAN           shift and go to state 126
    GTHAN_EQUAL     shift and go to state 127
    GTHAN           shift and go to state 128
    EQUAL           reduce using rule 108 (relational_expr -> additive_expr .)
    NEQUAL          reduce using rule 108 (relational_expr -> additive_expr .)
    AND             reduce using rule 108 (relational_expr -> additive_expr .)
    SEMI            reduce using rule 108 (relational_expr -> additive_expr .)
    OR              reduce using rule 108 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 108 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 108 (relational_expr -> additive_expr .)
    RBRACKET        reduce using rule 108 (relational_expr -> additive_expr .)
    PLUS            shift and go to state 129
    MINUS           shift and go to state 130


state 82

    (122) unary_expr -> PLUS . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    postfix_expr                   shift and go to state 131
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 83

    (113) additive_expr -> multiplicative_expr .
    (114) multiplicative_expr -> multiplicative_expr . TIMES parsed_times unary_expr
    (116) multiplicative_expr -> multiplicative_expr . DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> multiplicative_expr . MODULO parsed_modulo unary_expr

    LTHAN_EQUAL     reduce using rule 113 (additive_expr -> multiplicative_expr .)
    LTHAN           reduce using rule 113 (additive_expr -> multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 113 (additive_expr -> multiplicative_expr .)
    GTHAN           reduce using rule 113 (additive_expr -> multiplicative_expr .)
    PLUS            reduce using rule 113 (additive_expr -> multiplicative_expr .)
    MINUS           reduce using rule 113 (additive_expr -> multiplicative_expr .)
    EQUAL           reduce using rule 113 (additive_expr -> multiplicative_expr .)
    NEQUAL          reduce using rule 113 (additive_expr -> multiplicative_expr .)
    AND             reduce using rule 113 (additive_expr -> multiplicative_expr .)
    SEMI            reduce using rule 113 (additive_expr -> multiplicative_expr .)
    OR              reduce using rule 113 (additive_expr -> multiplicative_expr .)
    RPAREN          reduce using rule 113 (additive_expr -> multiplicative_expr .)
    COMMA           reduce using rule 113 (additive_expr -> multiplicative_expr .)
    RBRACKET        reduce using rule 113 (additive_expr -> multiplicative_expr .)
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    MODULO          shift and go to state 134


state 84

    (121) unary_expr -> MINUS . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    postfix_expr                   shift and go to state 135
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 85

    (120) multiplicative_expr -> unary_expr .

    TIMES           reduce using rule 120 (multiplicative_expr -> unary_expr .)
    DIVIDE          reduce using rule 120 (multiplicative_expr -> unary_expr .)
    MODULO          reduce using rule 120 (multiplicative_expr -> unary_expr .)
    LTHAN_EQUAL     reduce using rule 120 (multiplicative_expr -> unary_expr .)
    LTHAN           reduce using rule 120 (multiplicative_expr -> unary_expr .)
    GTHAN_EQUAL     reduce using rule 120 (multiplicative_expr -> unary_expr .)
    GTHAN           reduce using rule 120 (multiplicative_expr -> unary_expr .)
    PLUS            reduce using rule 120 (multiplicative_expr -> unary_expr .)
    MINUS           reduce using rule 120 (multiplicative_expr -> unary_expr .)
    EQUAL           reduce using rule 120 (multiplicative_expr -> unary_expr .)
    NEQUAL          reduce using rule 120 (multiplicative_expr -> unary_expr .)
    AND             reduce using rule 120 (multiplicative_expr -> unary_expr .)
    SEMI            reduce using rule 120 (multiplicative_expr -> unary_expr .)
    OR              reduce using rule 120 (multiplicative_expr -> unary_expr .)
    RPAREN          reduce using rule 120 (multiplicative_expr -> unary_expr .)
    COMMA           reduce using rule 120 (multiplicative_expr -> unary_expr .)
    RBRACKET        reduce using rule 120 (multiplicative_expr -> unary_expr .)


state 86

    (124) unary_expr -> postfix_expr .

    TIMES           reduce using rule 124 (unary_expr -> postfix_expr .)
    DIVIDE          reduce using rule 124 (unary_expr -> postfix_expr .)
    MODULO          reduce using rule 124 (unary_expr -> postfix_expr .)
    LTHAN_EQUAL     reduce using rule 124 (unary_expr -> postfix_expr .)
    LTHAN           reduce using rule 124 (unary_expr -> postfix_expr .)
    GTHAN_EQUAL     reduce using rule 124 (unary_expr -> postfix_expr .)
    GTHAN           reduce using rule 124 (unary_expr -> postfix_expr .)
    PLUS            reduce using rule 124 (unary_expr -> postfix_expr .)
    MINUS           reduce using rule 124 (unary_expr -> postfix_expr .)
    EQUAL           reduce using rule 124 (unary_expr -> postfix_expr .)
    NEQUAL          reduce using rule 124 (unary_expr -> postfix_expr .)
    AND             reduce using rule 124 (unary_expr -> postfix_expr .)
    SEMI            reduce using rule 124 (unary_expr -> postfix_expr .)
    OR              reduce using rule 124 (unary_expr -> postfix_expr .)
    RPAREN          reduce using rule 124 (unary_expr -> postfix_expr .)
    COMMA           reduce using rule 124 (unary_expr -> postfix_expr .)
    RBRACKET        reduce using rule 124 (unary_expr -> postfix_expr .)


state 87

    (123) unary_expr -> NOT . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    postfix_expr                   shift and go to state 136
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 88

    (125) postfix_expr -> LPAREN . expr RPAREN
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expr                           shift and go to state 137
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 89

    (126) postfix_expr -> variable_access .

    TIMES           reduce using rule 126 (postfix_expr -> variable_access .)
    DIVIDE          reduce using rule 126 (postfix_expr -> variable_access .)
    MODULO          reduce using rule 126 (postfix_expr -> variable_access .)
    LTHAN_EQUAL     reduce using rule 126 (postfix_expr -> variable_access .)
    LTHAN           reduce using rule 126 (postfix_expr -> variable_access .)
    GTHAN_EQUAL     reduce using rule 126 (postfix_expr -> variable_access .)
    GTHAN           reduce using rule 126 (postfix_expr -> variable_access .)
    PLUS            reduce using rule 126 (postfix_expr -> variable_access .)
    MINUS           reduce using rule 126 (postfix_expr -> variable_access .)
    EQUAL           reduce using rule 126 (postfix_expr -> variable_access .)
    NEQUAL          reduce using rule 126 (postfix_expr -> variable_access .)
    AND             reduce using rule 126 (postfix_expr -> variable_access .)
    SEMI            reduce using rule 126 (postfix_expr -> variable_access .)
    OR              reduce using rule 126 (postfix_expr -> variable_access .)
    RPAREN          reduce using rule 126 (postfix_expr -> variable_access .)
    COMMA           reduce using rule 126 (postfix_expr -> variable_access .)
    RBRACKET        reduce using rule 126 (postfix_expr -> variable_access .)


state 90

    (127) postfix_expr -> function_call .

    TIMES           reduce using rule 127 (postfix_expr -> function_call .)
    DIVIDE          reduce using rule 127 (postfix_expr -> function_call .)
    MODULO          reduce using rule 127 (postfix_expr -> function_call .)
    LTHAN_EQUAL     reduce using rule 127 (postfix_expr -> function_call .)
    LTHAN           reduce using rule 127 (postfix_expr -> function_call .)
    GTHAN_EQUAL     reduce using rule 127 (postfix_expr -> function_call .)
    GTHAN           reduce using rule 127 (postfix_expr -> function_call .)
    PLUS            reduce using rule 127 (postfix_expr -> function_call .)
    MINUS           reduce using rule 127 (postfix_expr -> function_call .)
    EQUAL           reduce using rule 127 (postfix_expr -> function_call .)
    NEQUAL          reduce using rule 127 (postfix_expr -> function_call .)
    AND             reduce using rule 127 (postfix_expr -> function_call .)
    SEMI            reduce using rule 127 (postfix_expr -> function_call .)
    OR              reduce using rule 127 (postfix_expr -> function_call .)
    RPAREN          reduce using rule 127 (postfix_expr -> function_call .)
    COMMA           reduce using rule 127 (postfix_expr -> function_call .)
    RBRACKET        reduce using rule 127 (postfix_expr -> function_call .)


state 91

    (128) postfix_expr -> constant .

    TIMES           reduce using rule 128 (postfix_expr -> constant .)
    DIVIDE          reduce using rule 128 (postfix_expr -> constant .)
    MODULO          reduce using rule 128 (postfix_expr -> constant .)
    LTHAN_EQUAL     reduce using rule 128 (postfix_expr -> constant .)
    LTHAN           reduce using rule 128 (postfix_expr -> constant .)
    GTHAN_EQUAL     reduce using rule 128 (postfix_expr -> constant .)
    GTHAN           reduce using rule 128 (postfix_expr -> constant .)
    PLUS            reduce using rule 128 (postfix_expr -> constant .)
    MINUS           reduce using rule 128 (postfix_expr -> constant .)
    EQUAL           reduce using rule 128 (postfix_expr -> constant .)
    NEQUAL          reduce using rule 128 (postfix_expr -> constant .)
    AND             reduce using rule 128 (postfix_expr -> constant .)
    SEMI            reduce using rule 128 (postfix_expr -> constant .)
    OR              reduce using rule 128 (postfix_expr -> constant .)
    RPAREN          reduce using rule 128 (postfix_expr -> constant .)
    COMMA           reduce using rule 128 (postfix_expr -> constant .)
    RBRACKET        reduce using rule 128 (postfix_expr -> constant .)


state 92

    (129) constant -> CONST_INT .

    TIMES           reduce using rule 129 (constant -> CONST_INT .)
    DIVIDE          reduce using rule 129 (constant -> CONST_INT .)
    MODULO          reduce using rule 129 (constant -> CONST_INT .)
    LTHAN_EQUAL     reduce using rule 129 (constant -> CONST_INT .)
    LTHAN           reduce using rule 129 (constant -> CONST_INT .)
    GTHAN_EQUAL     reduce using rule 129 (constant -> CONST_INT .)
    GTHAN           reduce using rule 129 (constant -> CONST_INT .)
    PLUS            reduce using rule 129 (constant -> CONST_INT .)
    MINUS           reduce using rule 129 (constant -> CONST_INT .)
    EQUAL           reduce using rule 129 (constant -> CONST_INT .)
    NEQUAL          reduce using rule 129 (constant -> CONST_INT .)
    AND             reduce using rule 129 (constant -> CONST_INT .)
    SEMI            reduce using rule 129 (constant -> CONST_INT .)
    OR              reduce using rule 129 (constant -> CONST_INT .)
    RPAREN          reduce using rule 129 (constant -> CONST_INT .)
    COMMA           reduce using rule 129 (constant -> CONST_INT .)
    RBRACKET        reduce using rule 129 (constant -> CONST_INT .)


state 93

    (130) constant -> CONST_REAL .

    TIMES           reduce using rule 130 (constant -> CONST_REAL .)
    DIVIDE          reduce using rule 130 (constant -> CONST_REAL .)
    MODULO          reduce using rule 130 (constant -> CONST_REAL .)
    LTHAN_EQUAL     reduce using rule 130 (constant -> CONST_REAL .)
    LTHAN           reduce using rule 130 (constant -> CONST_REAL .)
    GTHAN_EQUAL     reduce using rule 130 (constant -> CONST_REAL .)
    GTHAN           reduce using rule 130 (constant -> CONST_REAL .)
    PLUS            reduce using rule 130 (constant -> CONST_REAL .)
    MINUS           reduce using rule 130 (constant -> CONST_REAL .)
    EQUAL           reduce using rule 130 (constant -> CONST_REAL .)
    NEQUAL          reduce using rule 130 (constant -> CONST_REAL .)
    AND             reduce using rule 130 (constant -> CONST_REAL .)
    SEMI            reduce using rule 130 (constant -> CONST_REAL .)
    OR              reduce using rule 130 (constant -> CONST_REAL .)
    RPAREN          reduce using rule 130 (constant -> CONST_REAL .)
    COMMA           reduce using rule 130 (constant -> CONST_REAL .)
    RBRACKET        reduce using rule 130 (constant -> CONST_REAL .)


state 94

    (131) constant -> CONST_CHAR .

    TIMES           reduce using rule 131 (constant -> CONST_CHAR .)
    DIVIDE          reduce using rule 131 (constant -> CONST_CHAR .)
    MODULO          reduce using rule 131 (constant -> CONST_CHAR .)
    LTHAN_EQUAL     reduce using rule 131 (constant -> CONST_CHAR .)
    LTHAN           reduce using rule 131 (constant -> CONST_CHAR .)
    GTHAN_EQUAL     reduce using rule 131 (constant -> CONST_CHAR .)
    GTHAN           reduce using rule 131 (constant -> CONST_CHAR .)
    PLUS            reduce using rule 131 (constant -> CONST_CHAR .)
    MINUS           reduce using rule 131 (constant -> CONST_CHAR .)
    EQUAL           reduce using rule 131 (constant -> CONST_CHAR .)
    NEQUAL          reduce using rule 131 (constant -> CONST_CHAR .)
    AND             reduce using rule 131 (constant -> CONST_CHAR .)
    SEMI            reduce using rule 131 (constant -> CONST_CHAR .)
    OR              reduce using rule 131 (constant -> CONST_CHAR .)
    RPAREN          reduce using rule 131 (constant -> CONST_CHAR .)
    COMMA           reduce using rule 131 (constant -> CONST_CHAR .)
    RBRACKET        reduce using rule 131 (constant -> CONST_CHAR .)


state 95

    (132) constant -> CONST_STRING .

    TIMES           reduce using rule 132 (constant -> CONST_STRING .)
    DIVIDE          reduce using rule 132 (constant -> CONST_STRING .)
    MODULO          reduce using rule 132 (constant -> CONST_STRING .)
    LTHAN_EQUAL     reduce using rule 132 (constant -> CONST_STRING .)
    LTHAN           reduce using rule 132 (constant -> CONST_STRING .)
    GTHAN_EQUAL     reduce using rule 132 (constant -> CONST_STRING .)
    GTHAN           reduce using rule 132 (constant -> CONST_STRING .)
    PLUS            reduce using rule 132 (constant -> CONST_STRING .)
    MINUS           reduce using rule 132 (constant -> CONST_STRING .)
    EQUAL           reduce using rule 132 (constant -> CONST_STRING .)
    NEQUAL          reduce using rule 132 (constant -> CONST_STRING .)
    AND             reduce using rule 132 (constant -> CONST_STRING .)
    SEMI            reduce using rule 132 (constant -> CONST_STRING .)
    OR              reduce using rule 132 (constant -> CONST_STRING .)
    RPAREN          reduce using rule 132 (constant -> CONST_STRING .)
    COMMA           reduce using rule 132 (constant -> CONST_STRING .)
    RBRACKET        reduce using rule 132 (constant -> CONST_STRING .)


state 96

    (133) constant -> constant_bool .

    TIMES           reduce using rule 133 (constant -> constant_bool .)
    DIVIDE          reduce using rule 133 (constant -> constant_bool .)
    MODULO          reduce using rule 133 (constant -> constant_bool .)
    LTHAN_EQUAL     reduce using rule 133 (constant -> constant_bool .)
    LTHAN           reduce using rule 133 (constant -> constant_bool .)
    GTHAN_EQUAL     reduce using rule 133 (constant -> constant_bool .)
    GTHAN           reduce using rule 133 (constant -> constant_bool .)
    PLUS            reduce using rule 133 (constant -> constant_bool .)
    MINUS           reduce using rule 133 (constant -> constant_bool .)
    EQUAL           reduce using rule 133 (constant -> constant_bool .)
    NEQUAL          reduce using rule 133 (constant -> constant_bool .)
    AND             reduce using rule 133 (constant -> constant_bool .)
    SEMI            reduce using rule 133 (constant -> constant_bool .)
    OR              reduce using rule 133 (constant -> constant_bool .)
    RPAREN          reduce using rule 133 (constant -> constant_bool .)
    COMMA           reduce using rule 133 (constant -> constant_bool .)
    RBRACKET        reduce using rule 133 (constant -> constant_bool .)


state 97

    (134) constant_bool -> TRUE .

    TIMES           reduce using rule 134 (constant_bool -> TRUE .)
    DIVIDE          reduce using rule 134 (constant_bool -> TRUE .)
    MODULO          reduce using rule 134 (constant_bool -> TRUE .)
    LTHAN_EQUAL     reduce using rule 134 (constant_bool -> TRUE .)
    LTHAN           reduce using rule 134 (constant_bool -> TRUE .)
    GTHAN_EQUAL     reduce using rule 134 (constant_bool -> TRUE .)
    GTHAN           reduce using rule 134 (constant_bool -> TRUE .)
    PLUS            reduce using rule 134 (constant_bool -> TRUE .)
    MINUS           reduce using rule 134 (constant_bool -> TRUE .)
    EQUAL           reduce using rule 134 (constant_bool -> TRUE .)
    NEQUAL          reduce using rule 134 (constant_bool -> TRUE .)
    AND             reduce using rule 134 (constant_bool -> TRUE .)
    SEMI            reduce using rule 134 (constant_bool -> TRUE .)
    OR              reduce using rule 134 (constant_bool -> TRUE .)
    RPAREN          reduce using rule 134 (constant_bool -> TRUE .)
    COMMA           reduce using rule 134 (constant_bool -> TRUE .)
    RBRACKET        reduce using rule 134 (constant_bool -> TRUE .)


state 98

    (135) constant_bool -> FALSE .

    TIMES           reduce using rule 135 (constant_bool -> FALSE .)
    DIVIDE          reduce using rule 135 (constant_bool -> FALSE .)
    MODULO          reduce using rule 135 (constant_bool -> FALSE .)
    LTHAN_EQUAL     reduce using rule 135 (constant_bool -> FALSE .)
    LTHAN           reduce using rule 135 (constant_bool -> FALSE .)
    GTHAN_EQUAL     reduce using rule 135 (constant_bool -> FALSE .)
    GTHAN           reduce using rule 135 (constant_bool -> FALSE .)
    PLUS            reduce using rule 135 (constant_bool -> FALSE .)
    MINUS           reduce using rule 135 (constant_bool -> FALSE .)
    EQUAL           reduce using rule 135 (constant_bool -> FALSE .)
    NEQUAL          reduce using rule 135 (constant_bool -> FALSE .)
    AND             reduce using rule 135 (constant_bool -> FALSE .)
    SEMI            reduce using rule 135 (constant_bool -> FALSE .)
    OR              reduce using rule 135 (constant_bool -> FALSE .)
    RPAREN          reduce using rule 135 (constant_bool -> FALSE .)
    COMMA           reduce using rule 135 (constant_bool -> FALSE .)
    RBRACKET        reduce using rule 135 (constant_bool -> FALSE .)


state 99

    (53) variable_access -> ID parsed_id_variable_access . dims_access
    (55) dims_access -> . single_dim_access single_dim_access
    (56) dims_access -> . single_dim_access
    (57) dims_access -> . empty
    (58) single_dim_access -> . LBRACKET expr RBRACKET
    (140) empty -> .

    LBRACKET        shift and go to state 141
    ASGMT           reduce using rule 140 (empty -> .)
    TIMES           reduce using rule 140 (empty -> .)
    DIVIDE          reduce using rule 140 (empty -> .)
    MODULO          reduce using rule 140 (empty -> .)
    LTHAN_EQUAL     reduce using rule 140 (empty -> .)
    LTHAN           reduce using rule 140 (empty -> .)
    GTHAN_EQUAL     reduce using rule 140 (empty -> .)
    GTHAN           reduce using rule 140 (empty -> .)
    PLUS            reduce using rule 140 (empty -> .)
    MINUS           reduce using rule 140 (empty -> .)
    EQUAL           reduce using rule 140 (empty -> .)
    NEQUAL          reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    SEMI            reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    RPAREN          reduce using rule 140 (empty -> .)
    COMMA           reduce using rule 140 (empty -> .)
    RBRACKET        reduce using rule 140 (empty -> .)

    dims_access                    shift and go to state 138
    single_dim_access              shift and go to state 139
    empty                          shift and go to state 140

state 100

    (60) function_call -> ID parsed_function_call_id . LPAREN function_call_params RPAREN
    (61) function_call -> ID parsed_function_call_id . LPAREN RPAREN

    LPAREN          shift and go to state 142


state 101

    (77) while -> WHILE parsed_while . LPAREN expr parsed_while_expr RPAREN instruction_block

    LPAREN          shift and go to state 143


state 102

    (80) for -> FROM LPAREN . for_index COLON for_limit COLON for_step RPAREN instruction_block
    (81) for -> FROM LPAREN . for_index COLON for_limit for_no_step RPAREN instruction_block
    (82) for_index -> . ID ASGMT CONST_INT
    (83) for_index -> . ID ASGMT MINUS CONST_INT

    ID              shift and go to state 145

    for_index                      shift and go to state 144

state 103

    (25) single_function_definition_param -> type . ID

    ID              shift and go to state 146


state 104

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params . RPAREN local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params . RPAREN instruction_block
    (23) function_definition_params -> function_definition_params . COMMA single_function_definition_param

    RPAREN          shift and go to state 147
    COMMA           shift and go to state 148


state 105

    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN . local_variables_declaration instruction_block
    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN . instruction_block
    (29) local_variables_declaration -> . LOCAL variables_declaration
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 149
    instruction_block              shift and go to state 150

state 106

    (24) function_definition_params -> single_function_definition_param .

    RPAREN          reduce using rule 24 (function_definition_params -> single_function_definition_param .)
    COMMA           reduce using rule 24 (function_definition_params -> single_function_definition_param .)


state 107

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params . RPAREN local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params . RPAREN instruction_block
    (23) function_definition_params -> function_definition_params . COMMA single_function_definition_param

    RPAREN          shift and go to state 151
    COMMA           shift and go to state 148


state 108

    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN . local_variables_declaration instruction_block
    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN . instruction_block
    (29) local_variables_declaration -> . LOCAL variables_declaration
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 152
    instruction_block              shift and go to state 153

state 109

    (33) shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .

    INT             reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    REAL            reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    CHAR            reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    BOOL            reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    START           reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    FUNCTION        reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)
    LBRACE          reduce using rule 33 (shared_type_variables_declaration -> type parsed_type shared_type_variables_declaration_list SEMI .)


state 110

    (35) shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA . single_variable_declaration
    (37) single_variable_declaration -> . ID dim_definition dim_definition
    (38) single_variable_declaration -> . ID dim_definition
    (39) single_variable_declaration -> . ID

    ID              shift and go to state 69

    single_variable_declaration    shift and go to state 154

state 111

    (37) single_variable_declaration -> ID dim_definition . dim_definition
    (38) single_variable_declaration -> ID dim_definition .
    (40) dim_definition -> . LBRACKET CONST_INT RBRACKET

    SEMI            reduce using rule 38 (single_variable_declaration -> ID dim_definition .)
    COMMA           reduce using rule 38 (single_variable_declaration -> ID dim_definition .)
    LBRACKET        shift and go to state 112

    dim_definition                 shift and go to state 155

state 112

    (40) dim_definition -> LBRACKET . CONST_INT RBRACKET

    CONST_INT       shift and go to state 156


state 113

    (51) assignment -> variable_access ASGMT expr . SEMI
    (91) expr -> expr . OR and_expr

    SEMI            shift and go to state 157
    OR              shift and go to state 121


state 114

    (52) assignment -> variable_access ASGMT READ . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 158


state 115

    (66) print -> PRINT LPAREN print_params . RPAREN SEMI
    (68) print_params -> print_params . COMMA single_print_param

    RPAREN          shift and go to state 159
    COMMA           shift and go to state 160


state 116

    (67) print -> PRINT LPAREN RPAREN . SEMI

    SEMI            shift and go to state 161


state 117

    (69) print_params -> single_print_param .

    RPAREN          reduce using rule 69 (print_params -> single_print_param .)
    COMMA           reduce using rule 69 (print_params -> single_print_param .)


state 118

    (70) single_print_param -> expr .
    (91) expr -> expr . OR and_expr

    RPAREN          reduce using rule 70 (single_print_param -> expr .)
    COMMA           reduce using rule 70 (single_print_param -> expr .)
    OR              shift and go to state 121


state 119

    (71) conditional -> IF LPAREN expr . RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block
    (72) conditional -> IF LPAREN expr . RPAREN parsed_if_expr instruction_block
    (91) expr -> expr . OR and_expr

    RPAREN          shift and go to state 162
    OR              shift and go to state 121


state 120

    (89) return -> RETURN expr SEMI .

    RBRACE          reduce using rule 89 (return -> RETURN expr SEMI .)
    PRINT           reduce using rule 89 (return -> RETURN expr SEMI .)
    IF              reduce using rule 89 (return -> RETURN expr SEMI .)
    RETURN          reduce using rule 89 (return -> RETURN expr SEMI .)
    ID              reduce using rule 89 (return -> RETURN expr SEMI .)
    WHILE           reduce using rule 89 (return -> RETURN expr SEMI .)
    FROM            reduce using rule 89 (return -> RETURN expr SEMI .)


state 121

    (91) expr -> expr OR . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    and_expr                       shift and go to state 163
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 122

    (93) and_expr -> equality_expr AND . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    equality_expr                  shift and go to state 164
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 123

    (95) equality_expr -> relational_expr EQUAL . parsed_equal relational_expr
    (96) parsed_equal -> .

    MINUS           reduce using rule 96 (parsed_equal -> .)
    PLUS            reduce using rule 96 (parsed_equal -> .)
    NOT             reduce using rule 96 (parsed_equal -> .)
    LPAREN          reduce using rule 96 (parsed_equal -> .)
    ID              reduce using rule 96 (parsed_equal -> .)
    CONST_INT       reduce using rule 96 (parsed_equal -> .)
    CONST_REAL      reduce using rule 96 (parsed_equal -> .)
    CONST_CHAR      reduce using rule 96 (parsed_equal -> .)
    CONST_STRING    reduce using rule 96 (parsed_equal -> .)
    TRUE            reduce using rule 96 (parsed_equal -> .)
    FALSE           reduce using rule 96 (parsed_equal -> .)

    parsed_equal                   shift and go to state 165

state 124

    (97) equality_expr -> relational_expr NEQUAL . parsed_nequal relational_expr
    (98) parsed_nequal -> .

    MINUS           reduce using rule 98 (parsed_nequal -> .)
    PLUS            reduce using rule 98 (parsed_nequal -> .)
    NOT             reduce using rule 98 (parsed_nequal -> .)
    LPAREN          reduce using rule 98 (parsed_nequal -> .)
    ID              reduce using rule 98 (parsed_nequal -> .)
    CONST_INT       reduce using rule 98 (parsed_nequal -> .)
    CONST_REAL      reduce using rule 98 (parsed_nequal -> .)
    CONST_CHAR      reduce using rule 98 (parsed_nequal -> .)
    CONST_STRING    reduce using rule 98 (parsed_nequal -> .)
    TRUE            reduce using rule 98 (parsed_nequal -> .)
    FALSE           reduce using rule 98 (parsed_nequal -> .)

    parsed_nequal                  shift and go to state 166

state 125

    (100) relational_expr -> additive_expr LTHAN_EQUAL . parsed_lthan_equal additive_expr
    (101) parsed_lthan_equal -> .

    MINUS           reduce using rule 101 (parsed_lthan_equal -> .)
    PLUS            reduce using rule 101 (parsed_lthan_equal -> .)
    NOT             reduce using rule 101 (parsed_lthan_equal -> .)
    LPAREN          reduce using rule 101 (parsed_lthan_equal -> .)
    ID              reduce using rule 101 (parsed_lthan_equal -> .)
    CONST_INT       reduce using rule 101 (parsed_lthan_equal -> .)
    CONST_REAL      reduce using rule 101 (parsed_lthan_equal -> .)
    CONST_CHAR      reduce using rule 101 (parsed_lthan_equal -> .)
    CONST_STRING    reduce using rule 101 (parsed_lthan_equal -> .)
    TRUE            reduce using rule 101 (parsed_lthan_equal -> .)
    FALSE           reduce using rule 101 (parsed_lthan_equal -> .)

    parsed_lthan_equal             shift and go to state 167

state 126

    (102) relational_expr -> additive_expr LTHAN . parsed_lthan additive_expr
    (103) parsed_lthan -> .

    MINUS           reduce using rule 103 (parsed_lthan -> .)
    PLUS            reduce using rule 103 (parsed_lthan -> .)
    NOT             reduce using rule 103 (parsed_lthan -> .)
    LPAREN          reduce using rule 103 (parsed_lthan -> .)
    ID              reduce using rule 103 (parsed_lthan -> .)
    CONST_INT       reduce using rule 103 (parsed_lthan -> .)
    CONST_REAL      reduce using rule 103 (parsed_lthan -> .)
    CONST_CHAR      reduce using rule 103 (parsed_lthan -> .)
    CONST_STRING    reduce using rule 103 (parsed_lthan -> .)
    TRUE            reduce using rule 103 (parsed_lthan -> .)
    FALSE           reduce using rule 103 (parsed_lthan -> .)

    parsed_lthan                   shift and go to state 168

state 127

    (104) relational_expr -> additive_expr GTHAN_EQUAL . parsed_gthan_equal additive_expr
    (105) parsed_gthan_equal -> .

    MINUS           reduce using rule 105 (parsed_gthan_equal -> .)
    PLUS            reduce using rule 105 (parsed_gthan_equal -> .)
    NOT             reduce using rule 105 (parsed_gthan_equal -> .)
    LPAREN          reduce using rule 105 (parsed_gthan_equal -> .)
    ID              reduce using rule 105 (parsed_gthan_equal -> .)
    CONST_INT       reduce using rule 105 (parsed_gthan_equal -> .)
    CONST_REAL      reduce using rule 105 (parsed_gthan_equal -> .)
    CONST_CHAR      reduce using rule 105 (parsed_gthan_equal -> .)
    CONST_STRING    reduce using rule 105 (parsed_gthan_equal -> .)
    TRUE            reduce using rule 105 (parsed_gthan_equal -> .)
    FALSE           reduce using rule 105 (parsed_gthan_equal -> .)

    parsed_gthan_equal             shift and go to state 169

state 128

    (106) relational_expr -> additive_expr GTHAN . parsed_gthan additive_expr
    (107) parsed_gthan -> .

    MINUS           reduce using rule 107 (parsed_gthan -> .)
    PLUS            reduce using rule 107 (parsed_gthan -> .)
    NOT             reduce using rule 107 (parsed_gthan -> .)
    LPAREN          reduce using rule 107 (parsed_gthan -> .)
    ID              reduce using rule 107 (parsed_gthan -> .)
    CONST_INT       reduce using rule 107 (parsed_gthan -> .)
    CONST_REAL      reduce using rule 107 (parsed_gthan -> .)
    CONST_CHAR      reduce using rule 107 (parsed_gthan -> .)
    CONST_STRING    reduce using rule 107 (parsed_gthan -> .)
    TRUE            reduce using rule 107 (parsed_gthan -> .)
    FALSE           reduce using rule 107 (parsed_gthan -> .)

    parsed_gthan                   shift and go to state 170

state 129

    (109) additive_expr -> additive_expr PLUS . parsed_plus multiplicative_expr
    (110) parsed_plus -> .

    MINUS           reduce using rule 110 (parsed_plus -> .)
    PLUS            reduce using rule 110 (parsed_plus -> .)
    NOT             reduce using rule 110 (parsed_plus -> .)
    LPAREN          reduce using rule 110 (parsed_plus -> .)
    ID              reduce using rule 110 (parsed_plus -> .)
    CONST_INT       reduce using rule 110 (parsed_plus -> .)
    CONST_REAL      reduce using rule 110 (parsed_plus -> .)
    CONST_CHAR      reduce using rule 110 (parsed_plus -> .)
    CONST_STRING    reduce using rule 110 (parsed_plus -> .)
    TRUE            reduce using rule 110 (parsed_plus -> .)
    FALSE           reduce using rule 110 (parsed_plus -> .)

    parsed_plus                    shift and go to state 171

state 130

    (111) additive_expr -> additive_expr MINUS . parsed_minus multiplicative_expr
    (112) parsed_minus -> .

    MINUS           reduce using rule 112 (parsed_minus -> .)
    PLUS            reduce using rule 112 (parsed_minus -> .)
    NOT             reduce using rule 112 (parsed_minus -> .)
    LPAREN          reduce using rule 112 (parsed_minus -> .)
    ID              reduce using rule 112 (parsed_minus -> .)
    CONST_INT       reduce using rule 112 (parsed_minus -> .)
    CONST_REAL      reduce using rule 112 (parsed_minus -> .)
    CONST_CHAR      reduce using rule 112 (parsed_minus -> .)
    CONST_STRING    reduce using rule 112 (parsed_minus -> .)
    TRUE            reduce using rule 112 (parsed_minus -> .)
    FALSE           reduce using rule 112 (parsed_minus -> .)

    parsed_minus                   shift and go to state 172

state 131

    (122) unary_expr -> PLUS postfix_expr .

    TIMES           reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    DIVIDE          reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    MODULO          reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    LTHAN_EQUAL     reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    LTHAN           reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    GTHAN_EQUAL     reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    GTHAN           reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    PLUS            reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    MINUS           reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    EQUAL           reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    NEQUAL          reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    AND             reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    SEMI            reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    OR              reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    RPAREN          reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    COMMA           reduce using rule 122 (unary_expr -> PLUS postfix_expr .)
    RBRACKET        reduce using rule 122 (unary_expr -> PLUS postfix_expr .)


state 132

    (114) multiplicative_expr -> multiplicative_expr TIMES . parsed_times unary_expr
    (115) parsed_times -> .

    MINUS           reduce using rule 115 (parsed_times -> .)
    PLUS            reduce using rule 115 (parsed_times -> .)
    NOT             reduce using rule 115 (parsed_times -> .)
    LPAREN          reduce using rule 115 (parsed_times -> .)
    ID              reduce using rule 115 (parsed_times -> .)
    CONST_INT       reduce using rule 115 (parsed_times -> .)
    CONST_REAL      reduce using rule 115 (parsed_times -> .)
    CONST_CHAR      reduce using rule 115 (parsed_times -> .)
    CONST_STRING    reduce using rule 115 (parsed_times -> .)
    TRUE            reduce using rule 115 (parsed_times -> .)
    FALSE           reduce using rule 115 (parsed_times -> .)

    parsed_times                   shift and go to state 173

state 133

    (116) multiplicative_expr -> multiplicative_expr DIVIDE . parsed_divide unary_expr
    (117) parsed_divide -> .

    MINUS           reduce using rule 117 (parsed_divide -> .)
    PLUS            reduce using rule 117 (parsed_divide -> .)
    NOT             reduce using rule 117 (parsed_divide -> .)
    LPAREN          reduce using rule 117 (parsed_divide -> .)
    ID              reduce using rule 117 (parsed_divide -> .)
    CONST_INT       reduce using rule 117 (parsed_divide -> .)
    CONST_REAL      reduce using rule 117 (parsed_divide -> .)
    CONST_CHAR      reduce using rule 117 (parsed_divide -> .)
    CONST_STRING    reduce using rule 117 (parsed_divide -> .)
    TRUE            reduce using rule 117 (parsed_divide -> .)
    FALSE           reduce using rule 117 (parsed_divide -> .)

    parsed_divide                  shift and go to state 174

state 134

    (118) multiplicative_expr -> multiplicative_expr MODULO . parsed_modulo unary_expr
    (119) parsed_modulo -> .

    MINUS           reduce using rule 119 (parsed_modulo -> .)
    PLUS            reduce using rule 119 (parsed_modulo -> .)
    NOT             reduce using rule 119 (parsed_modulo -> .)
    LPAREN          reduce using rule 119 (parsed_modulo -> .)
    ID              reduce using rule 119 (parsed_modulo -> .)
    CONST_INT       reduce using rule 119 (parsed_modulo -> .)
    CONST_REAL      reduce using rule 119 (parsed_modulo -> .)
    CONST_CHAR      reduce using rule 119 (parsed_modulo -> .)
    CONST_STRING    reduce using rule 119 (parsed_modulo -> .)
    TRUE            reduce using rule 119 (parsed_modulo -> .)
    FALSE           reduce using rule 119 (parsed_modulo -> .)

    parsed_modulo                  shift and go to state 175

state 135

    (121) unary_expr -> MINUS postfix_expr .

    TIMES           reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    DIVIDE          reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    MODULO          reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    LTHAN_EQUAL     reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    LTHAN           reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    GTHAN_EQUAL     reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    GTHAN           reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    PLUS            reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    MINUS           reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    EQUAL           reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    NEQUAL          reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    AND             reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    SEMI            reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    OR              reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    RPAREN          reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    COMMA           reduce using rule 121 (unary_expr -> MINUS postfix_expr .)
    RBRACKET        reduce using rule 121 (unary_expr -> MINUS postfix_expr .)


state 136

    (123) unary_expr -> NOT postfix_expr .

    TIMES           reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    DIVIDE          reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    MODULO          reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    LTHAN_EQUAL     reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    LTHAN           reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    GTHAN_EQUAL     reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    GTHAN           reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    PLUS            reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    MINUS           reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    EQUAL           reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    NEQUAL          reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    AND             reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    SEMI            reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    OR              reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    RPAREN          reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    COMMA           reduce using rule 123 (unary_expr -> NOT postfix_expr .)
    RBRACKET        reduce using rule 123 (unary_expr -> NOT postfix_expr .)


state 137

    (125) postfix_expr -> LPAREN expr . RPAREN
    (91) expr -> expr . OR and_expr

    RPAREN          shift and go to state 176
    OR              shift and go to state 121


state 138

    (53) variable_access -> ID parsed_id_variable_access dims_access .

    ASGMT           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    TIMES           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    DIVIDE          reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    MODULO          reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    LTHAN_EQUAL     reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    LTHAN           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    GTHAN_EQUAL     reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    GTHAN           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    PLUS            reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    MINUS           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    EQUAL           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    NEQUAL          reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    AND             reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    SEMI            reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    OR              reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    RPAREN          reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    COMMA           reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)
    RBRACKET        reduce using rule 53 (variable_access -> ID parsed_id_variable_access dims_access .)


state 139

    (55) dims_access -> single_dim_access . single_dim_access
    (56) dims_access -> single_dim_access .
    (58) single_dim_access -> . LBRACKET expr RBRACKET

    ASGMT           reduce using rule 56 (dims_access -> single_dim_access .)
    TIMES           reduce using rule 56 (dims_access -> single_dim_access .)
    DIVIDE          reduce using rule 56 (dims_access -> single_dim_access .)
    MODULO          reduce using rule 56 (dims_access -> single_dim_access .)
    LTHAN_EQUAL     reduce using rule 56 (dims_access -> single_dim_access .)
    LTHAN           reduce using rule 56 (dims_access -> single_dim_access .)
    GTHAN_EQUAL     reduce using rule 56 (dims_access -> single_dim_access .)
    GTHAN           reduce using rule 56 (dims_access -> single_dim_access .)
    PLUS            reduce using rule 56 (dims_access -> single_dim_access .)
    MINUS           reduce using rule 56 (dims_access -> single_dim_access .)
    EQUAL           reduce using rule 56 (dims_access -> single_dim_access .)
    NEQUAL          reduce using rule 56 (dims_access -> single_dim_access .)
    AND             reduce using rule 56 (dims_access -> single_dim_access .)
    SEMI            reduce using rule 56 (dims_access -> single_dim_access .)
    OR              reduce using rule 56 (dims_access -> single_dim_access .)
    RPAREN          reduce using rule 56 (dims_access -> single_dim_access .)
    COMMA           reduce using rule 56 (dims_access -> single_dim_access .)
    RBRACKET        reduce using rule 56 (dims_access -> single_dim_access .)
    LBRACKET        shift and go to state 141

    single_dim_access              shift and go to state 177

state 140

    (57) dims_access -> empty .

    ASGMT           reduce using rule 57 (dims_access -> empty .)
    TIMES           reduce using rule 57 (dims_access -> empty .)
    DIVIDE          reduce using rule 57 (dims_access -> empty .)
    MODULO          reduce using rule 57 (dims_access -> empty .)
    LTHAN_EQUAL     reduce using rule 57 (dims_access -> empty .)
    LTHAN           reduce using rule 57 (dims_access -> empty .)
    GTHAN_EQUAL     reduce using rule 57 (dims_access -> empty .)
    GTHAN           reduce using rule 57 (dims_access -> empty .)
    PLUS            reduce using rule 57 (dims_access -> empty .)
    MINUS           reduce using rule 57 (dims_access -> empty .)
    EQUAL           reduce using rule 57 (dims_access -> empty .)
    NEQUAL          reduce using rule 57 (dims_access -> empty .)
    AND             reduce using rule 57 (dims_access -> empty .)
    SEMI            reduce using rule 57 (dims_access -> empty .)
    OR              reduce using rule 57 (dims_access -> empty .)
    RPAREN          reduce using rule 57 (dims_access -> empty .)
    COMMA           reduce using rule 57 (dims_access -> empty .)
    RBRACKET        reduce using rule 57 (dims_access -> empty .)


state 141

    (58) single_dim_access -> LBRACKET . expr RBRACKET
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expr                           shift and go to state 178
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 142

    (60) function_call -> ID parsed_function_call_id LPAREN . function_call_params RPAREN
    (61) function_call -> ID parsed_function_call_id LPAREN . RPAREN
    (63) function_call_params -> . function_call_params COMMA single_function_call_param
    (64) function_call_params -> . single_function_call_param
    (65) single_function_call_param -> . expr
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    RPAREN          shift and go to state 180
    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    function_call_params           shift and go to state 179
    single_function_call_param     shift and go to state 181
    expr                           shift and go to state 182
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 143

    (77) while -> WHILE parsed_while LPAREN . expr parsed_while_expr RPAREN instruction_block
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    expr                           shift and go to state 183
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 144

    (80) for -> FROM LPAREN for_index . COLON for_limit COLON for_step RPAREN instruction_block
    (81) for -> FROM LPAREN for_index . COLON for_limit for_no_step RPAREN instruction_block

    COLON           shift and go to state 184


state 145

    (82) for_index -> ID . ASGMT CONST_INT
    (83) for_index -> ID . ASGMT MINUS CONST_INT

    ASGMT           shift and go to state 185


state 146

    (25) single_function_definition_param -> type ID .

    RPAREN          reduce using rule 25 (single_function_definition_param -> type ID .)
    COMMA           reduce using rule 25 (single_function_definition_param -> type ID .)


state 147

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN . local_variables_declaration instruction_block
    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN . instruction_block
    (29) local_variables_declaration -> . LOCAL variables_declaration
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 186
    instruction_block              shift and go to state 187

state 148

    (23) function_definition_params -> function_definition_params COMMA . single_function_definition_param
    (25) single_function_definition_param -> . type ID
    (136) type -> . INT
    (137) type -> . REAL
    (138) type -> . CHAR
    (139) type -> . BOOL

    INT             shift and go to state 19
    REAL            shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22

    single_function_definition_param shift and go to state 188
    type                           shift and go to state 103

state 149

    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 189

state 150

    (14) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block .

    START           reduce using rule 14 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block .)
    FUNCTION        reduce using rule 14 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN instruction_block .)


state 151

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN . local_variables_declaration instruction_block
    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN . instruction_block
    (29) local_variables_declaration -> . LOCAL variables_declaration
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LOCAL           shift and go to state 38
    LBRACE          shift and go to state 39

    local_variables_declaration    shift and go to state 190
    instruction_block              shift and go to state 191

state 152

    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 192

state 153

    (18) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block .

    START           reduce using rule 18 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block .)
    FUNCTION        reduce using rule 18 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN instruction_block .)


state 154

    (35) shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .

    SEMI            reduce using rule 35 (shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .)
    COMMA           reduce using rule 35 (shared_type_variables_declaration_list -> shared_type_variables_declaration_list COMMA single_variable_declaration .)


state 155

    (37) single_variable_declaration -> ID dim_definition dim_definition .

    SEMI            reduce using rule 37 (single_variable_declaration -> ID dim_definition dim_definition .)
    COMMA           reduce using rule 37 (single_variable_declaration -> ID dim_definition dim_definition .)


state 156

    (40) dim_definition -> LBRACKET CONST_INT . RBRACKET

    RBRACKET        shift and go to state 193


state 157

    (51) assignment -> variable_access ASGMT expr SEMI .

    RBRACE          reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    PRINT           reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    IF              reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    RETURN          reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    ID              reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    WHILE           reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)
    FROM            reduce using rule 51 (assignment -> variable_access ASGMT expr SEMI .)


state 158

    (52) assignment -> variable_access ASGMT READ LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 194


state 159

    (66) print -> PRINT LPAREN print_params RPAREN . SEMI

    SEMI            shift and go to state 195


state 160

    (68) print_params -> print_params COMMA . single_print_param
    (70) single_print_param -> . expr
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    single_print_param             shift and go to state 196
    expr                           shift and go to state 118
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 161

    (67) print -> PRINT LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)
    PRINT           reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)
    IF              reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)
    ID              reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)
    WHILE           reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)
    FROM            reduce using rule 67 (print -> PRINT LPAREN RPAREN SEMI .)


state 162

    (71) conditional -> IF LPAREN expr RPAREN . parsed_if_expr instruction_block ELSE parsed_else instruction_block
    (72) conditional -> IF LPAREN expr RPAREN . parsed_if_expr instruction_block
    (73) parsed_if_expr -> .

    LBRACE          reduce using rule 73 (parsed_if_expr -> .)

    parsed_if_expr                 shift and go to state 197

state 163

    (91) expr -> expr OR and_expr .

    SEMI            reduce using rule 91 (expr -> expr OR and_expr .)
    OR              reduce using rule 91 (expr -> expr OR and_expr .)
    RPAREN          reduce using rule 91 (expr -> expr OR and_expr .)
    COMMA           reduce using rule 91 (expr -> expr OR and_expr .)
    RBRACKET        reduce using rule 91 (expr -> expr OR and_expr .)


state 164

    (93) and_expr -> equality_expr AND equality_expr .

    SEMI            reduce using rule 93 (and_expr -> equality_expr AND equality_expr .)
    OR              reduce using rule 93 (and_expr -> equality_expr AND equality_expr .)
    RPAREN          reduce using rule 93 (and_expr -> equality_expr AND equality_expr .)
    COMMA           reduce using rule 93 (and_expr -> equality_expr AND equality_expr .)
    RBRACKET        reduce using rule 93 (and_expr -> equality_expr AND equality_expr .)


state 165

    (95) equality_expr -> relational_expr EQUAL parsed_equal . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    relational_expr                shift and go to state 198
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 166

    (97) equality_expr -> relational_expr NEQUAL parsed_nequal . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    relational_expr                shift and go to state 199
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 167

    (100) relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    additive_expr                  shift and go to state 200
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 168

    (102) relational_expr -> additive_expr LTHAN parsed_lthan . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    additive_expr                  shift and go to state 201
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 169

    (104) relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    additive_expr                  shift and go to state 202
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 170

    (106) relational_expr -> additive_expr GTHAN parsed_gthan . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    additive_expr                  shift and go to state 203
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 171

    (109) additive_expr -> additive_expr PLUS parsed_plus . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    multiplicative_expr            shift and go to state 204
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 172

    (111) additive_expr -> additive_expr MINUS parsed_minus . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    multiplicative_expr            shift and go to state 205
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 173

    (114) multiplicative_expr -> multiplicative_expr TIMES parsed_times . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    unary_expr                     shift and go to state 206
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 174

    (116) multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    unary_expr                     shift and go to state 207
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 175

    (118) multiplicative_expr -> multiplicative_expr MODULO parsed_modulo . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    unary_expr                     shift and go to state 208
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 176

    (125) postfix_expr -> LPAREN expr RPAREN .

    TIMES           reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    MODULO          reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    LTHAN_EQUAL     reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    LTHAN           reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    GTHAN_EQUAL     reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    GTHAN           reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    NEQUAL          reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 125 (postfix_expr -> LPAREN expr RPAREN .)


state 177

    (55) dims_access -> single_dim_access single_dim_access .

    ASGMT           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    TIMES           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    DIVIDE          reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    MODULO          reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    LTHAN_EQUAL     reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    LTHAN           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    GTHAN_EQUAL     reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    GTHAN           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    PLUS            reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    MINUS           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    EQUAL           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    NEQUAL          reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    AND             reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    SEMI            reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    OR              reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    RPAREN          reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    COMMA           reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)
    RBRACKET        reduce using rule 55 (dims_access -> single_dim_access single_dim_access .)


state 178

    (58) single_dim_access -> LBRACKET expr . RBRACKET
    (91) expr -> expr . OR and_expr

    RBRACKET        shift and go to state 209
    OR              shift and go to state 121


state 179

    (60) function_call -> ID parsed_function_call_id LPAREN function_call_params . RPAREN
    (63) function_call_params -> function_call_params . COMMA single_function_call_param

    RPAREN          shift and go to state 210
    COMMA           shift and go to state 211


state 180

    (61) function_call -> ID parsed_function_call_id LPAREN RPAREN .

    SEMI            reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    TIMES           reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    DIVIDE          reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    MODULO          reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    LTHAN_EQUAL     reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    LTHAN           reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    GTHAN_EQUAL     reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    GTHAN           reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    PLUS            reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    MINUS           reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    EQUAL           reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    NEQUAL          reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    AND             reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    OR              reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    RPAREN          reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    COMMA           reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)
    RBRACKET        reduce using rule 61 (function_call -> ID parsed_function_call_id LPAREN RPAREN .)


state 181

    (64) function_call_params -> single_function_call_param .

    RPAREN          reduce using rule 64 (function_call_params -> single_function_call_param .)
    COMMA           reduce using rule 64 (function_call_params -> single_function_call_param .)


state 182

    (65) single_function_call_param -> expr .
    (91) expr -> expr . OR and_expr

    RPAREN          reduce using rule 65 (single_function_call_param -> expr .)
    COMMA           reduce using rule 65 (single_function_call_param -> expr .)
    OR              shift and go to state 121


state 183

    (77) while -> WHILE parsed_while LPAREN expr . parsed_while_expr RPAREN instruction_block
    (91) expr -> expr . OR and_expr
    (79) parsed_while_expr -> .

    OR              shift and go to state 121
    RPAREN          reduce using rule 79 (parsed_while_expr -> .)

    parsed_while_expr              shift and go to state 212

state 184

    (80) for -> FROM LPAREN for_index COLON . for_limit COLON for_step RPAREN instruction_block
    (81) for -> FROM LPAREN for_index COLON . for_limit for_no_step RPAREN instruction_block
    (84) for_limit -> . CONST_INT
    (85) for_limit -> . MINUS CONST_INT

    CONST_INT       shift and go to state 214
    MINUS           shift and go to state 215

    for_limit                      shift and go to state 213

state 185

    (82) for_index -> ID ASGMT . CONST_INT
    (83) for_index -> ID ASGMT . MINUS CONST_INT

    CONST_INT       shift and go to state 216
    MINUS           shift and go to state 217


state 186

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 218

state 187

    (12) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block .

    START           reduce using rule 12 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block .)
    FUNCTION        reduce using rule 12 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN instruction_block .)


state 188

    (23) function_definition_params -> function_definition_params COMMA single_function_definition_param .

    RPAREN          reduce using rule 23 (function_definition_params -> function_definition_params COMMA single_function_definition_param .)
    COMMA           reduce using rule 23 (function_definition_params -> function_definition_params COMMA single_function_definition_param .)


state 189

    (13) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 13 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 13 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN RPAREN local_variables_declaration instruction_block .)


state 190

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 219

state 191

    (16) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block .

    START           reduce using rule 16 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block .)
    FUNCTION        reduce using rule 16 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN instruction_block .)


state 192

    (17) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 17 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 17 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN RPAREN local_variables_declaration instruction_block .)


state 193

    (40) dim_definition -> LBRACKET CONST_INT RBRACKET .

    LBRACKET        reduce using rule 40 (dim_definition -> LBRACKET CONST_INT RBRACKET .)
    SEMI            reduce using rule 40 (dim_definition -> LBRACKET CONST_INT RBRACKET .)
    COMMA           reduce using rule 40 (dim_definition -> LBRACKET CONST_INT RBRACKET .)


state 194

    (52) assignment -> variable_access ASGMT READ LPAREN RPAREN . SEMI

    SEMI            shift and go to state 220


state 195

    (66) print -> PRINT LPAREN print_params RPAREN SEMI .

    RBRACE          reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    PRINT           reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    IF              reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    RETURN          reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    ID              reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    WHILE           reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)
    FROM            reduce using rule 66 (print -> PRINT LPAREN print_params RPAREN SEMI .)


state 196

    (68) print_params -> print_params COMMA single_print_param .

    RPAREN          reduce using rule 68 (print_params -> print_params COMMA single_print_param .)
    COMMA           reduce using rule 68 (print_params -> print_params COMMA single_print_param .)


state 197

    (71) conditional -> IF LPAREN expr RPAREN parsed_if_expr . instruction_block ELSE parsed_else instruction_block
    (72) conditional -> IF LPAREN expr RPAREN parsed_if_expr . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 221

state 198

    (95) equality_expr -> relational_expr EQUAL parsed_equal relational_expr .

    AND             reduce using rule 95 (equality_expr -> relational_expr EQUAL parsed_equal relational_expr .)
    SEMI            reduce using rule 95 (equality_expr -> relational_expr EQUAL parsed_equal relational_expr .)
    OR              reduce using rule 95 (equality_expr -> relational_expr EQUAL parsed_equal relational_expr .)
    RPAREN          reduce using rule 95 (equality_expr -> relational_expr EQUAL parsed_equal relational_expr .)
    COMMA           reduce using rule 95 (equality_expr -> relational_expr EQUAL parsed_equal relational_expr .)
    RBRACKET        reduce using rule 95 (equality_expr -> relational_expr EQUAL parsed_equal relational_expr .)


state 199

    (97) equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .

    AND             reduce using rule 97 (equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .)
    SEMI            reduce using rule 97 (equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .)
    OR              reduce using rule 97 (equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .)
    RPAREN          reduce using rule 97 (equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .)
    COMMA           reduce using rule 97 (equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .)
    RBRACKET        reduce using rule 97 (equality_expr -> relational_expr NEQUAL parsed_nequal relational_expr .)


state 200

    (100) relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .
    (109) additive_expr -> additive_expr . PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> additive_expr . MINUS parsed_minus multiplicative_expr

    EQUAL           reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    NEQUAL          reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    AND             reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    SEMI            reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    OR              reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    RPAREN          reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    COMMA           reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    RBRACKET        reduce using rule 100 (relational_expr -> additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr .)
    PLUS            shift and go to state 129
    MINUS           shift and go to state 130


state 201

    (102) relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .
    (109) additive_expr -> additive_expr . PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> additive_expr . MINUS parsed_minus multiplicative_expr

    EQUAL           reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    NEQUAL          reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    AND             reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    SEMI            reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    OR              reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    RPAREN          reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    COMMA           reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    RBRACKET        reduce using rule 102 (relational_expr -> additive_expr LTHAN parsed_lthan additive_expr .)
    PLUS            shift and go to state 129
    MINUS           shift and go to state 130


state 202

    (104) relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .
    (109) additive_expr -> additive_expr . PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> additive_expr . MINUS parsed_minus multiplicative_expr

    EQUAL           reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    NEQUAL          reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    AND             reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    SEMI            reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    OR              reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    RPAREN          reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    COMMA           reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    RBRACKET        reduce using rule 104 (relational_expr -> additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr .)
    PLUS            shift and go to state 129
    MINUS           shift and go to state 130


state 203

    (106) relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .
    (109) additive_expr -> additive_expr . PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> additive_expr . MINUS parsed_minus multiplicative_expr

    EQUAL           reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    NEQUAL          reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    AND             reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    SEMI            reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    OR              reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    RPAREN          reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    COMMA           reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    RBRACKET        reduce using rule 106 (relational_expr -> additive_expr GTHAN parsed_gthan additive_expr .)
    PLUS            shift and go to state 129
    MINUS           shift and go to state 130


state 204

    (109) additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .
    (114) multiplicative_expr -> multiplicative_expr . TIMES parsed_times unary_expr
    (116) multiplicative_expr -> multiplicative_expr . DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> multiplicative_expr . MODULO parsed_modulo unary_expr

    LTHAN_EQUAL     reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    LTHAN           reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    GTHAN           reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    PLUS            reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    MINUS           reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    EQUAL           reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    NEQUAL          reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    AND             reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    SEMI            reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    OR              reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    RPAREN          reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    COMMA           reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    RBRACKET        reduce using rule 109 (additive_expr -> additive_expr PLUS parsed_plus multiplicative_expr .)
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    MODULO          shift and go to state 134


state 205

    (111) additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .
    (114) multiplicative_expr -> multiplicative_expr . TIMES parsed_times unary_expr
    (116) multiplicative_expr -> multiplicative_expr . DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> multiplicative_expr . MODULO parsed_modulo unary_expr

    LTHAN_EQUAL     reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    LTHAN           reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    GTHAN_EQUAL     reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    GTHAN           reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    PLUS            reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    MINUS           reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    EQUAL           reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    NEQUAL          reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    AND             reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    SEMI            reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    OR              reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    RPAREN          reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    COMMA           reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    RBRACKET        reduce using rule 111 (additive_expr -> additive_expr MINUS parsed_minus multiplicative_expr .)
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    MODULO          shift and go to state 134


state 206

    (114) multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .

    TIMES           reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    DIVIDE          reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    MODULO          reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    LTHAN_EQUAL     reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    LTHAN           reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    GTHAN_EQUAL     reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    GTHAN           reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    PLUS            reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    MINUS           reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    EQUAL           reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    NEQUAL          reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    AND             reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    SEMI            reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    OR              reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    RPAREN          reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    COMMA           reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)
    RBRACKET        reduce using rule 114 (multiplicative_expr -> multiplicative_expr TIMES parsed_times unary_expr .)


state 207

    (116) multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .

    TIMES           reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    DIVIDE          reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    MODULO          reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    LTHAN_EQUAL     reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    LTHAN           reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    GTHAN_EQUAL     reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    GTHAN           reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    PLUS            reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    MINUS           reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    EQUAL           reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    NEQUAL          reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    AND             reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    SEMI            reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    OR              reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    RPAREN          reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    COMMA           reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)
    RBRACKET        reduce using rule 116 (multiplicative_expr -> multiplicative_expr DIVIDE parsed_divide unary_expr .)


state 208

    (118) multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .

    TIMES           reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    DIVIDE          reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    MODULO          reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    LTHAN_EQUAL     reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    LTHAN           reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    GTHAN_EQUAL     reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    GTHAN           reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    PLUS            reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    MINUS           reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    EQUAL           reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    NEQUAL          reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    AND             reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    SEMI            reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    OR              reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    RPAREN          reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    COMMA           reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)
    RBRACKET        reduce using rule 118 (multiplicative_expr -> multiplicative_expr MODULO parsed_modulo unary_expr .)


state 209

    (58) single_dim_access -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    ASGMT           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    LTHAN_EQUAL     reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    LTHAN           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    GTHAN_EQUAL     reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    GTHAN           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    NEQUAL          reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 58 (single_dim_access -> LBRACKET expr RBRACKET .)


state 210

    (60) function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .

    SEMI            reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    TIMES           reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    DIVIDE          reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    MODULO          reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    LTHAN_EQUAL     reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    LTHAN           reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    GTHAN_EQUAL     reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    GTHAN           reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    PLUS            reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    MINUS           reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    EQUAL           reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    NEQUAL          reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    AND             reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    OR              reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    RPAREN          reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    COMMA           reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)
    RBRACKET        reduce using rule 60 (function_call -> ID parsed_function_call_id LPAREN function_call_params RPAREN .)


state 211

    (63) function_call_params -> function_call_params COMMA . single_function_call_param
    (65) single_function_call_param -> . expr
    (91) expr -> . expr OR and_expr
    (92) expr -> . and_expr
    (93) and_expr -> . equality_expr AND equality_expr
    (94) and_expr -> . equality_expr
    (95) equality_expr -> . relational_expr EQUAL parsed_equal relational_expr
    (97) equality_expr -> . relational_expr NEQUAL parsed_nequal relational_expr
    (99) equality_expr -> . relational_expr
    (100) relational_expr -> . additive_expr LTHAN_EQUAL parsed_lthan_equal additive_expr
    (102) relational_expr -> . additive_expr LTHAN parsed_lthan additive_expr
    (104) relational_expr -> . additive_expr GTHAN_EQUAL parsed_gthan_equal additive_expr
    (106) relational_expr -> . additive_expr GTHAN parsed_gthan additive_expr
    (108) relational_expr -> . additive_expr
    (109) additive_expr -> . additive_expr PLUS parsed_plus multiplicative_expr
    (111) additive_expr -> . additive_expr MINUS parsed_minus multiplicative_expr
    (113) additive_expr -> . multiplicative_expr
    (114) multiplicative_expr -> . multiplicative_expr TIMES parsed_times unary_expr
    (116) multiplicative_expr -> . multiplicative_expr DIVIDE parsed_divide unary_expr
    (118) multiplicative_expr -> . multiplicative_expr MODULO parsed_modulo unary_expr
    (120) multiplicative_expr -> . unary_expr
    (121) unary_expr -> . MINUS postfix_expr
    (122) unary_expr -> . PLUS postfix_expr
    (123) unary_expr -> . NOT postfix_expr
    (124) unary_expr -> . postfix_expr
    (125) postfix_expr -> . LPAREN expr RPAREN
    (126) postfix_expr -> . variable_access
    (127) postfix_expr -> . function_call
    (128) postfix_expr -> . constant
    (53) variable_access -> . ID parsed_id_variable_access dims_access
    (60) function_call -> . ID parsed_function_call_id LPAREN function_call_params RPAREN
    (61) function_call -> . ID parsed_function_call_id LPAREN RPAREN
    (129) constant -> . CONST_INT
    (130) constant -> . CONST_REAL
    (131) constant -> . CONST_CHAR
    (132) constant -> . CONST_STRING
    (133) constant -> . constant_bool
    (134) constant_bool -> . TRUE
    (135) constant_bool -> . FALSE

    MINUS           shift and go to state 84
    PLUS            shift and go to state 82
    NOT             shift and go to state 87
    LPAREN          shift and go to state 88
    ID              shift and go to state 62
    CONST_INT       shift and go to state 92
    CONST_REAL      shift and go to state 93
    CONST_CHAR      shift and go to state 94
    CONST_STRING    shift and go to state 95
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    single_function_call_param     shift and go to state 222
    expr                           shift and go to state 182
    and_expr                       shift and go to state 78
    equality_expr                  shift and go to state 79
    relational_expr                shift and go to state 80
    additive_expr                  shift and go to state 81
    multiplicative_expr            shift and go to state 83
    unary_expr                     shift and go to state 85
    postfix_expr                   shift and go to state 86
    variable_access                shift and go to state 89
    function_call                  shift and go to state 90
    constant                       shift and go to state 91
    constant_bool                  shift and go to state 96

state 212

    (77) while -> WHILE parsed_while LPAREN expr parsed_while_expr . RPAREN instruction_block

    RPAREN          shift and go to state 223


state 213

    (80) for -> FROM LPAREN for_index COLON for_limit . COLON for_step RPAREN instruction_block
    (81) for -> FROM LPAREN for_index COLON for_limit . for_no_step RPAREN instruction_block
    (86) for_no_step -> .

    COLON           shift and go to state 224
    RPAREN          reduce using rule 86 (for_no_step -> .)

    for_no_step                    shift and go to state 225

state 214

    (84) for_limit -> CONST_INT .

    COLON           reduce using rule 84 (for_limit -> CONST_INT .)
    RPAREN          reduce using rule 84 (for_limit -> CONST_INT .)


state 215

    (85) for_limit -> MINUS . CONST_INT

    CONST_INT       shift and go to state 226


state 216

    (82) for_index -> ID ASGMT CONST_INT .

    COLON           reduce using rule 82 (for_index -> ID ASGMT CONST_INT .)


state 217

    (83) for_index -> ID ASGMT MINUS . CONST_INT

    CONST_INT       shift and go to state 227


state 218

    (11) single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 11 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 11 (single_function_definition -> FUNCTION type parsed_function_return_type ID parsed_type_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)


state 219

    (15) single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .

    START           reduce using rule 15 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)
    FUNCTION        reduce using rule 15 (single_function_definition -> FUNCTION VOID parsed_function_void_return_type ID parsed_void_function_id LPAREN function_definition_params RPAREN local_variables_declaration instruction_block .)


state 220

    (52) assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .

    RBRACE          reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)
    PRINT           reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)
    IF              reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)
    ID              reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)
    WHILE           reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)
    FROM            reduce using rule 52 (assignment -> variable_access ASGMT READ LPAREN RPAREN SEMI .)


state 221

    (71) conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block . ELSE parsed_else instruction_block
    (72) conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .

    ELSE            shift and go to state 228
    RBRACE          reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)
    PRINT           reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)
    IF              reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)
    RETURN          reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)
    ID              reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)
    WHILE           reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)
    FROM            reduce using rule 72 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block .)


state 222

    (63) function_call_params -> function_call_params COMMA single_function_call_param .

    RPAREN          reduce using rule 63 (function_call_params -> function_call_params COMMA single_function_call_param .)
    COMMA           reduce using rule 63 (function_call_params -> function_call_params COMMA single_function_call_param .)


state 223

    (77) while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 229

state 224

    (80) for -> FROM LPAREN for_index COLON for_limit COLON . for_step RPAREN instruction_block
    (87) for_step -> . CONST_INT
    (88) for_step -> . MINUS CONST_INT

    CONST_INT       shift and go to state 231
    MINUS           shift and go to state 232

    for_step                       shift and go to state 230

state 225

    (81) for -> FROM LPAREN for_index COLON for_limit for_no_step . RPAREN instruction_block

    RPAREN          shift and go to state 233


state 226

    (85) for_limit -> MINUS CONST_INT .

    COLON           reduce using rule 85 (for_limit -> MINUS CONST_INT .)
    RPAREN          reduce using rule 85 (for_limit -> MINUS CONST_INT .)


state 227

    (83) for_index -> ID ASGMT MINUS CONST_INT .

    COLON           reduce using rule 83 (for_index -> ID ASGMT MINUS CONST_INT .)


state 228

    (71) conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE . parsed_else instruction_block
    (74) parsed_else -> .

    LBRACE          reduce using rule 74 (parsed_else -> .)

    parsed_else                    shift and go to state 234

state 229

    (77) while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .

    RBRACE          reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)
    PRINT           reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)
    IF              reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)
    RETURN          reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)
    ID              reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)
    WHILE           reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)
    FROM            reduce using rule 77 (while -> WHILE parsed_while LPAREN expr parsed_while_expr RPAREN instruction_block .)


state 230

    (80) for -> FROM LPAREN for_index COLON for_limit COLON for_step . RPAREN instruction_block

    RPAREN          shift and go to state 235


state 231

    (87) for_step -> CONST_INT .

    RPAREN          reduce using rule 87 (for_step -> CONST_INT .)


state 232

    (88) for_step -> MINUS . CONST_INT

    CONST_INT       shift and go to state 236


state 233

    (81) for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 237

state 234

    (71) conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 238

state 235

    (80) for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN . instruction_block
    (41) instruction_block -> . LBRACE statements RBRACE
    (42) instruction_block -> . LBRACE RBRACE

    LBRACE          shift and go to state 39

    instruction_block              shift and go to state 239

state 236

    (88) for_step -> MINUS CONST_INT .

    RPAREN          reduce using rule 88 (for_step -> MINUS CONST_INT .)


state 237

    (81) for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .

    RBRACE          reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)
    PRINT           reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)
    IF              reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)
    RETURN          reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)
    ID              reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)
    WHILE           reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)
    FROM            reduce using rule 81 (for -> FROM LPAREN for_index COLON for_limit for_no_step RPAREN instruction_block .)


state 238

    (71) conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .

    RBRACE          reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)
    PRINT           reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)
    IF              reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)
    RETURN          reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)
    ID              reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)
    WHILE           reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)
    FROM            reduce using rule 71 (conditional -> IF LPAREN expr RPAREN parsed_if_expr instruction_block ELSE parsed_else instruction_block .)


state 239

    (80) for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .

    RBRACE          reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)
    PRINT           reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)
    IF              reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)
    RETURN          reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)
    ID              reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)
    WHILE           reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)
    FROM            reduce using rule 80 (for -> FROM LPAREN for_index COLON for_limit COLON for_step RPAREN instruction_block .)

